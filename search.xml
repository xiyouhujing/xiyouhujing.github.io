<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java笔记：数组的定义及使用]]></title>
    <url>%2F2019%2F03%2F30%2FJava%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一维数组数组是一组相关数据的集合，一个数组实际上就是一连串的变量，数组按使用可以分为一维数组、二位数组和多维数组。 一维数组可以存放上千万个数据，并且这些数据的类型完全相同。要使用Java的数组，必须经过声明数组和分配内存给数组两个步骤，一维数组的声明与分配内存的语法结构如下： 12数据类型 数组名[] = null; // 声明一维数组数组名 = new 数据类型[长度]； // 分配内存给数组 对于数组的声明方式也可以用下面的形式： 1数据类型[] 数组名 = null; // 声明一维数组 在数组的声明格式中，“数据类型”指的是声明数组元素的数据类型，常见的类型有整型、浮点型与字符型等。“数组名”是用来统一这组相同数据类型的元素的名称，其命名规则和变量相同。数组声明后实际上在内存中保存了此数组的名称（实际上是保存对一堆内存的引用地址），接下来便要在堆内存中配置数组所需的内存。其中，“长度”是告诉编辑器所声明的数组要存放多少个元素，而关键字new则是命令编译器根据括号里的长度在堆内存中开辟一块堆内存供该数组使用，例如： 12int score[] = null; // 声明整型数组scorescore = new int[3]; // 为整型数组score分配内存空间，其元素个数为3 当声明一个整型数组score时，score可视为数组类型的变量，此时，这个变量并没有包含任何内容，编译器仅会在栈内存中分配一块内存给它，用来指向数组实体的地址的名称。声明之后，就要做堆内存分配的操作了，也就是上面第二行的语句，这一行会开辟3个可供保存整数的内存空间，并把此内存空间的参考地址赋给score变量。因为数组是引用数据类型，所以数组变量score所保存的并非是数组的实体，而是数组堆内存的参考地址。 堆栈内存的解释 数组操作中，在栈内存中保存的永远是数组的名称，只开辟了栈内存空间的数组是永远无法使用的，必须有指向的堆内存才可以使用，要想开辟新的堆内存则必须使用关键字new，然后只是将此堆内存的使用权交给了对应的栈内存空间，而且一个堆内存空间可以同时被多个栈内存空间所指向。 另外，可以在声明数组的同时分配内存空间，其格式如下： 1数据类型 数组名[] = new 数据类型[个数] 例如： 1int score[] = new int[10]; //声明一个元素个数为10的整数数组score，同时开辟一块内存空间供其使用 数组中元素的表示方法若要访问数组中的元素，可以利用索引来完成，Java的数组索引编号由0开始，以score[10]整型数组为例，score[0]代表第一个元素，而score[9]代表第10个元素，也就是最后一个元素。 数组的声明及输出： 123456789101112public class ArrayDemo01 &#123; public static void main(String[] args) &#123; int score[] = null; // 声明数组，但未开辟堆内存空间 score = new int[3]; // 为数组开辟堆内存空间 System.out.println("score[0] = " + score[0]); // 分别输出每个元素 System.out.println("score[1] = " + score[1]); // 分别输出每个元素 System.out.println("score[2] = " + score[2]); // 分别输出每个元素 for (int x = 0; x &lt; 3; x++)&#123; // 使用循环依此输出数组中的全部内容 System.out.println("score["+x+"] = " + score[x]); &#125; &#125;&#125; 程序运行结果为： 123456score[0] = 0score[1] = 0score[2] = 0score[0] = 0score[1] = 0score[2] = 0 从运行结果可以看出，对于数组的访问采用“数组名称[下标]”的方式，之前一共开辟了3个空间大小的数组，所以下标的取值为0~2，如果超出了这个下标，例如score[3]，则会出现如下错误：java.lang.ArrayIndexOutOfBoundsException:3。 此外，可以发现以上数组中的内容都是0，这是因为声明的是整型数组，而此时又没有为整型数组中的内容赋值，所以现在都是默认值，整型的默认值为0。下面的范例将为数组中的元素进行赋值并输出： 123456789101112public class ArrayDemo02 &#123; public static void main(String[] args) &#123; int score[] = null; score = new int[3]; for (int x = 0; x &lt; 3; x++)&#123; score[x] = x * 2 + 1; &#125; for (int x = 0; x &lt; 3; x++)&#123; System.out.println("score[" + x + "] = " + score[x]); &#125; &#125;&#125; 程序运行结果为： 123score[0] = 1score[1] = 3score[2] = 5 在Java中取得数组的长度（也就是数组元素的长度）可以利用“数组名称.length”的形式，会返回一个int型数据。例如 123456public class ArrayDemo03 &#123; public static void main(String[] args) &#123; int score[] = new int[3]; System.out.println("数组长度为" + score.length); &#125;&#125; 程序的运行结果为：数组长度为3 数组的静态初始化数组的内容分为动态初始化和静态初始化两种，之前所讲的代码是采用先声明数组之后为数组中的每个内容赋值的方式完成的，所以属于数组的动态初始化，也可以通过数组静态初始化，在数组声明时就指定其具体内容，只要在数组的声明格式后面加上初值的赋值即可，如下： 1数据类型 数组名[] = &#123;初值0，初值1，···，初值n&#125; 在大括号内的初值会依此指定给数组的第1、···、n个元素。此外，在声明时，并不需要将数组元素的个数列出来，编译器根据所给出的初值个数来判断数组的长度。 12345678public class ArrayDemo04 &#123; public static void main(String[] args) &#123; int score[] = &#123;91, 92, 93, 94, 95, 96&#125;; for (int x = 0; x &lt; score.length; x++)&#123; System.out.println("score[" + x + "] = " + score[x]); &#125; &#125;&#125; 程序运行结果为： 123456score[0] = 91score[1] = 92score[2] = 93score[3] = 94score[4] = 95score[5] = 96 数组应用范例 求出数组中的最大和最小值 123456789101112131415161718public class ArrayDemo05 &#123; public static void main(String[] args) &#123; int score[] = &#123;67, 89, 87, 69, 90, 100, 75, 90&#125;; // 静态初始化数组 int max = 0; // 定义变量保存最大值 int min = 0; // 定义变量保存最小值 max = min = score[0]; // 把第一个元素的内容赋值给max和min for (int x = 0; x &lt; score.length; x++)&#123; if (score[x] &gt; max)&#123; // 依此判断后续元素是否比max大 max = score[x]; // 如果大，则修改max内容 &#125; if (score[x] &lt; min)&#123; // 依此判断后续的元素是否比min小 min = score[x]; // 如果小，则修改min内容 &#125; &#125; System.out.println("最高成绩：" + max); // 输出最大值 System.out.println("最低成绩：" + min); // 输出最小值 &#125;&#125; 程序运行结果： 12最高成绩：100最低成绩：67 本程序中，首先将数组的最大和最小值都当作数组中的第一个元素，然后用for循环依此和数组后面的元素比较，如果比当前的max值大，则将该值赋给max，如果比当前的min值小，则将该值赋给min，直到数组里的元素都比较完毕，max存储了数组中的最大值，min存储了数组里的最小值。 对整型数组按照由小到大的顺序进行排列 1234567891011121314151617public class ArrayDemo06 &#123; public static void main(String[] args) &#123; int score[] = &#123;67, 89, 87, 69, 90, 100, 75, 90&#125;; // 声明数组 for (int i = 1; i &lt; score.length; i++)&#123; // 循环判断 for (int j = 0; j &lt; score.length; j++)&#123; if (score[i] &lt; score[j])&#123; // 交换位置 int temp = score[i]; score[i] = score[j]; score[j] = temp; &#125; &#125; &#125; for (int i = 0; i &lt; score.length; i++)&#123; System.out.println(score[i] + "\t"); &#125; &#125;&#125; 程序运行结果为：67 69 75 87 89 90 90 100。 以上程序采用了冒泡算法进行排序。即把数组中的每个元素进行比较，如果第i个元素大于第i+1个元素，那么就要把两个数字进行交换，这样反复的比较就可以将一个数组按照由大到小的顺序进行排序。 修改之前的代码，显示每次的排序结果 1234567891011121314151617181920212223public class ArrayDemo07 &#123; public static void main(String[] args) &#123; int score[] = &#123;67, 89, 87, 69, 90, 100, 75, 90&#125;; // 声明数组 for (int i = 1; i &lt; score.length; i++)&#123; for (int j = 0; j &lt; score.length; j++)&#123; if (score[i] &lt; score[j])&#123; int temp = score[i]; score[i] = score[j]; score[j] = temp; &#125; &#125; System.out.print("第"+i+"次排序的结果：\t"); for (int j = 0; j &lt; score.length; j++)&#123; // 循环输出 System.out.print(score[j] + "\t"); &#125; System.out.println(""); // 换行 &#125; System.out.print("最终的排序结果为：\t"); for (int i = 0; i &lt; score.length; i++)&#123; System.out.print(score[i] + "\t"); &#125; &#125;&#125; 程序运行结果为： 12345678第1次排序的结果： 67 100 87 69 89 90 75 90 第2次排序的结果： 67 87 100 69 89 90 75 90 第3次排序的结果： 67 69 87 100 89 90 75 90 第4次排序的结果： 67 69 87 89 100 90 75 90 第5次排序的结果： 67 69 87 89 90 100 75 90 第6次排序的结果： 67 69 75 87 89 90 100 90 第7次排序的结果： 67 69 75 87 89 90 90 100 最终的排序结果为： 67 69 75 87 89 90 90 100 二维数组二维数组的声明方式和一维数组类似，内存的分配也要使用关键字new完成，其声明与分配内存的格式如下： 12数据类型 数组名[][];数组名 = new 数据类型[][]; 与一维数组不同的是，二维数组在分配内存时，必须告诉编译器二维数组的行与列的个数，例如： 12int score[][]; // 声明整型数组scorescore = new int[4][3]; // 配置一块内存空间，供4行3列的整型数组score使用 同样的，也可以利用较为简洁的声明和分配内存语句： 1数据类型 数组名[][] = new 数据类型[行的个数][列的个数] 二维数组的定义及使用： 12345678910111213141516public class ArrayDemo08 &#123; public static void main(String[] args) &#123; int score[][] = new int[4][3]; // 声明并实例化二维数组 score[0][1] = 30; score[1][0] = 31; score[2][2] = 32; score[3][1] = 33; score[1][1] = 30; for (int i = 0; i &lt; score.length; i++)&#123; for (int j = 0; j &lt; score[i].length; j++)&#123; System.out.print(score[i][j] + "\t"); &#125; System.out.println(""); &#125; &#125;&#125; 程序运行结果为： 12340 30 0 31 30 0 0 0 32 0 33 0 可以看出，一维数组输出只需要使用一层循环，而二维数组全部输出则需要使用两层循环，同理，对于N维数组，则要使用N+1层循环。 二维数组也可以利用大括号进行静态初始化，只要在数组的声明格式后面再加上所赋的初值即可，格式如下： 123456数组类型 数组名[][] = &#123; &#123;第0行初值&#125;， &#123;第1行初值&#125;， ··· &#123;第n行初值&#125;&#125;； 要特别注意的是，用户不必定义数组的长度，因此，在数组名后面的中括号中不必填入任何内容。下面是二维数组声明及赋初值的例子： 123456789101112public class ArrayDemo09 &#123; public static void main(String[] args) &#123; // 静态初始化一个二维数组，每行的数组元素个数都不一样 int score[][] = &#123;&#123;67, 61&#125;, &#123;78, 89, 83&#125;, &#123;99, 100, 98, 66, 95&#125;&#125;; for (int i = 0; i &lt; score.length; i++)&#123; for (int j = 0; j &lt; score[i].length; j++)&#123; System.out.print(score[i][j] + "\t"); &#125; System.out.println(""); &#125; &#125;&#125; 程序运行结果如下： 12367 61 78 89 83 99 100 98 66 95 多维数组想要提高数组的维数，只要在声明数组时将索引与中括号再加一组即可，即三维数组的声明为int score[][][]，而四维数组的声明为int score[][][][]···，依此类推。使用多维数组时，输入、输出的方式和一维、二维数组相同，但是每多一维，嵌套循环的层数就必须多一层，所以维数越高的数组其复杂度也就越高。例如下面是三维数组的使用： 12345678910111213public class ArrayDemo10 &#123; public static void main(String[] args) &#123; // 定义一个三维数组，使用静态初始化的方式 int score[][][] = &#123;&#123;&#123;5, 1&#125;, &#123;6, 7&#125;&#125;, &#123;&#123;9, 4&#125;, &#123;8, 3&#125;&#125;&#125;; for (int i = 0; i &lt; score.length; i++)&#123; for (int j = 0; j &lt; score[i].length; j++)&#123; for (int k = 0; k &lt; score[i][j].length; k++)&#123; System.out.println("score[" + i + "][" + j + "][" + k +"]=" + score[i][j][k]); &#125; &#125; &#125; &#125;&#125; 程序运行结果为： 12345678score[0][0][0]=5score[0][0][1]=1score[0][1][0]=6score[0][1][1]=7score[1][0][0]=9score[1][0][1]=4score[1][1][0]=8score[1][1][1]=3]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java开发实战经典习题3.7]]></title>
    <url>%2F2019%2F03%2F21%2FJava%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E7%BB%8F%E5%85%B8%E4%B9%A0%E9%A2%983-7%2F</url>
    <content type="text"><![CDATA[打印出1~10000范围中所有的“水仙花数”，所谓“水仙花数”是指一个3位数，其各位数字立方和等于该数本身。例如，153就是一个“水仙花数”，因为153=（1的三次方+5的三次方+3的三次方）。123456789101112131415/**首先“水仙花数”是一个三位数，所以题目给的1~10000的范围是比较大的，可以缩小为100~999，另外需要明白这题需要用到循环结构，一次验证范围内的3位数是为“水仙花数”，我们可以采用while、do···while以及for循环中的任意一种，这里采用的是for循环。本题 一个难点是如何提取个十百位的数，我们可以采用取余算法（%）。然后用if语句判断该数是否为“水仙化数”，是就打印，不是就再执行for循环验证下一个数。*/public class test3_1 &#123; public static void main(String[] args) &#123; for (int i = 100; i &lt; 1000; i++)&#123; int m = i % 10; // 取个位数 int n = (i / 10) % 10; // 取十位数 int h = i / 100; // 取百位数 if (i == m * m * m + n * n * n + h * h * h)&#123; // 验证是否为水仙花数 System.out.println(i + "是水仙花数"); &#125; &#125; &#125;&#125; 程序运行结果为： 1234153是水仙花数370是水仙花数371是水仙花数407是水仙花数 通过代码完成两个整数内容的交换12345678910public class test3_2 &#123; public static void main(String[] args) &#123; int a = 10, b = 5; System.out.println("交换之前的内容：" + "a = " + a + "，b = " + b); a = a + b; b = a - b; a = a - b; System.out.println("交换之后的内容：" + "a = " + a + "，b = " + b); &#125;&#125; 程序运行结果为： 12交换之前的内容：a = 10，b = 5交换之后的内容：a = 5，b = 10 给定3个数字，求出这3个数字中的最大值，并将最大值输出12345678public class test3_3 &#123; public static void main(String[] args) &#123; int a = 3, b = 5, c = 4; int max = 0; max = a &gt; b ? (a &gt; c ? a : c) : (b &gt; c ? b : c); System.out.println("最大值为：" + max); &#125;&#125; 程序运行结果为： 1最大值为：5 判断某数能否被3、5、7同时整除12345678910public class test3_4 &#123; public static void main(String[] args) &#123; int num = 105; if (num%3==0 &amp;&amp; num%5==0 &amp;&amp; num%7==0) &#123; System.out.println(num + "能被3、5、7同时整除"); &#125;else &#123; System.out.println(num + "不能被3、5、7同时整除"); &#125; &#125;&#125; 程序运行结果为： 1105能被3、5、7同时整除 变写程序，分别利用while循环、do···while循环和for循环求出100~200的累加和。123456789101112131415161718192021222324252627282930313233343536373839404142/**while循环求100~200的累加和*/public class test3_5_1 &#123; public static void main(String[] args) &#123; int i = 100; int sum = 0; while (i &lt;= 200)&#123; sum += i; i++; &#125; System.out.println("100~200的累加和为：" + sum); &#125;&#125;/**do···while循环求100~200的累加和。*/public class test3_5_2 &#123; public static void main(String[] args) &#123; int i = 100; int sum = 0; do &#123; sum += i; i++; &#125;while (i &lt;= 200); System.out.println("100~200的累加和为：" + sum); &#125;&#125;/**for循环求100~200的累加和。*/public class test3_5_3 &#123; public static void main(String[] args) &#123; int sum = 0; for (int i = 100; i &lt;= 200; i++)&#123; sum += i; &#125; System.out.println("100~200的累加和为：" + sum); &#125;&#125; 编写程序Java程序，求13-23+33-43+···+973-983+993-1003的值123456789101112131415161718public class test3_6 &#123; public static void main(String[] args) &#123; int count = 1; int sum = 0; int x = 13; while (x &lt;= 1003)&#123; if (count % 2 == 1)&#123; sum += x; &#125;else &#123; sum -= x; &#125; x += 10; count++; &#125; System.out.println("3-23+33-43+···+973-983+993-1003 = " + sum); &#125;&#125; 程序运行结果为： 13-23+33-43+···+973-983+993-1003 = -500 编写一个程序，实现两个数字的交换。1234567891011/**这一题我理解为交换两位数的个位和十位。*/public class Test3_7 &#123; public static void main(String[] args) &#123; int a = 35; int n = a % 10; int m = a / 10; System.out.println("交换后的数字为：" + (n*10+m)); &#125;&#125; 编写一个程序求3个数中的最大值1参考第三题 编写一个程序，实现1~100的累加123456789public class Test3_9 &#123; public static void main(String[] args) &#123; int sum = 0; for (int i = 1; i &lt;= 100; i++)&#123; sum += i; &#125; System.out.println("1~100的累加和为：" + sum); &#125;&#125; 求1~1000之间可以同时被3、5、7整除的数字。123456789public class Test3_10 &#123; public static void main(String[] args) &#123; for (int i = 1; i &lt;= 1000; i++)&#123; if (i%3==0 &amp;&amp; i%5==0 &amp;&amp; i%7==0)&#123; System.out.println(i); &#125; &#125; &#125;&#125; 编程求1!+2!+3!+···+20!的值。1234567891011121314/**此处需要注意，阶乘是很大的数，所以不能按常规设定阶乘pro和阶乘累加和sum为int型，范围可能不够大，所以设为long型数据。*/public class Test3_11 &#123; public static void main(String[] args) &#123; long sum = 0; long pro = 1; for (int i = 1; i &lt;= 20; i++)&#123; pro *= i; // 计算每项的阶乘 sum += pro; // 计算每项阶乘的累加和 &#125; System.out.println("1!+2!+3!+...+20! = " + sum); &#125;&#125; 程序运行结果为： 11!+2!+3!+...+20! = 2561327494111820313 使用for循环打印由*组成的三角形，三角形每行的星数和行数相等12345678910111213public class Test3_12 &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt;= 4-i; j++) &#123; System.out.print(" "); // 注意print为不换行输出 &#125; for (int k = 0; k &lt;= i; k++) &#123; System.out.print("* "); // print不换行输出，注意星号后面还需要打印一个空格，不然三角形不对称 &#125; System.out.println(" "); // println换行输出 &#125; &#125;&#125; 程序运行的结果如图：]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java选择和循环语句]]></title>
    <url>%2F2019%2F03%2F18%2FJava%E7%AC%94%E8%AE%B0%EF%BC%9A%E9%80%89%E6%8B%A9%E5%92%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[程序的结构一般来说程序的结构可以分为顺序结构、选择结构以及循环结构三种，这三种结构只有一个共同点，就是它们只有一个入口，也只有一个出口，这些单一的入、出口可以让程序易读、好维护，也可以减少调试时间。 顺序结构顺序结构下的程序至上而下的逐条执行，一条语句执行完之后继续执行下一条语句，一直到程序的末尾，其结构如下图所示： 选择结构选择结构的流程图如下，这种结构可以依据判断条件的结构来决定要执行的语句，当判断条件的值为真时，就运行语句1；当判断的条件为假，则执行语句2。不论执行哪一句，最后都会回到语句3继续执行。选择结构的流程图如下： 验证选择结构： 1234567891011121314public class IfDemo &#123; public static void main(String[] args) &#123; int x = 3; int y = 10; System.out.println("======比较开始====="); if (x &gt; y)&#123; System.out.println("x比y大！"); &#125; if (x &lt; y)&#123; System.out.println("x比y小！"); &#125; System.out.println("=====比较完成====="); &#125;&#125; 程序运行结果： 123======比较开始=====x比y小！=====比较完成===== 选择结构包括if、if···else及switch语句。 if语句要根据判断的结果来执行不同的语句时，使用if语句是一个很好的选择，它会准确地判断条件成立与否，再决定是否要执行后面的语句。if语句的格式如下： 12345if (判断条件) &#123; 语句1; ··· 语句2;&#125; 当判断条件的值不满足时（true），就会逐一执行大括号里面所有的语句，否则执行大括号外的语句。 if···else语句当程序中存在含有分支的判断语句时，就可以用if···else语句处理，当判断条件成立时，即执行if语句主题；判断条件不成立时，则会执行else后面的语句主题。if···else语句的格式如下： 12345if (判断条件) &#123; 语句主体1;&#125;else &#123; 语句主体2;&#125; 例如，通过if···else语句判断一个数字是奇数还是偶数： 12345678910public class IfElseDemo &#123; public static void main(String[] args) &#123; int x = 3; if (x % 2 == 1) &#123; System.out.println("x是基数！"); &#125;else &#123; System.out.println("x是偶数！"); &#125; &#125;&#125; 三目运算符三目运算符可以等价于使用if···else进行变量赋值的语句。如下表所示： 三目运算符 意义 ?: 根据条件的成立与否来决定结果为“：”前或者“：”后的表达式 三目运算符的使用格式如下： 1变量 = 条件判断?表达式1:表达式2 该语句的意思是，当条件成立时执行表达式1，否则执行表达式2，通常会将这两个表达式之一的运算结果指定给某个变量，用if···else表示为： 12345if (条件判断)&#123; 变量x = 表达式1;&#125;else&#123; 变量x = 表达式2；&#125; 例如，使用三目运算符求出两个数字中的最大值： 123456789public class MaxDemo &#123; public static void main(String[] args) &#123; int max = 0; int x = 3; int y = 10; max = x &gt; y ? x:y; System.out.println("最大值为：" + max); &#125;&#125; if···else if···else语句如果需要在if···else中判断多个条件时，就需要if···else if···else语句了，其格式如下： 123456789if (条件判断1) &#123; 语句主体1;&#125;else if (条件判断2) &#123; 语句主体2;&#125;··· // 多个else if()语句else&#123; 语句主体3;&#125; 例如： 1234567891011121314public class MoreIfElseDemo &#123; public static void main(String[] args) &#123; int x = 3; if (x ==1) &#123; System.out.println("x的值是1！"); &#125;else if (x == 2) &#123; System.out.println("x的值是2！"); &#125;else if (x == 3) &#123; System.out.println("x的值是3！"); &#125;else &#123; System.out.println("x的值不是1、2、3中的一个！"); &#125; &#125;&#125; switch语句switch语句可以将多选一的情况简化，使程序简洁易懂，使用嵌套if···else语句最常发生的状况就是容易将if与else配对混淆，从而造成阅读及运行上的错误，而使用switch语句则可以避免这种错误发生，switch语句的格式如下： 12345678910switch (表达式) &#123; case 选择值1: 语句主体1; break； case 选择值2: 语句主体2： break; …… case 选择值n: 语句主体n; break; default: 语句主体;&#125; 特别注意的是，在switch语句中选择值只能是字符或常量，在JDK 1.5之后，switch也支持枚举类的判断。 switch语句执行的流程如下： （1） switch语句先计算括号内的表达式结果，结果是数字、字符或者枚举。 （2）根据表达式的值检测是否符合case后面的选择值，若是所有case的选择值皆不符合，则执行default所包含的语句，执行完毕即离开switch语句。 （3）如果某个case的选择值符合表达式的结果，就会执行该case所包含的语句，一直遇到break语句后才离开switch语句 （4）如果没有在case语句结尾处加上break语句，则会一直执行到switch语句的尾端才离开switch语句。 （5）若是没有定义default执行语句，则什么都不会执行，直接退出switch语句。 根据以上描述，绘制如下的switch语句的流程图： 以下程序验证了switch语句的作用： 1234567891011121314151617181920212223242526272829public class SwitchDemo01 &#123; public static void main(String[] args) &#123; int x = 3; int y = 6; char oper = '+'; switch (oper)&#123; case '+':&#123; System.out.println("x + y =" + (x + y)); break; &#125; case '-':&#123; System.out.println("x - y = " + (x - y)); break; &#125; case '*':&#123; System.out.println("x * y = " + (x * y)); break; &#125; case '/':&#123; System.out.println("x / y = " + (x / y)); break; &#125; default:&#123; System.out.println("未知操作！"); break; &#125; &#125; &#125;&#125; 程序的运行结果为：x + y = 9 break语句的作用 从以上程序可以发现，在每一个case语句后面都加上了break语句，如果不加，则switch语句会从第一个满足条件的case开始依此执行操作，例如： 12345678910111213141516171819202122232425&gt; public class SwitchDemo02 &#123;&gt; public static void main(String[] args) &#123;&gt; int x = 3;&gt; int y = 6;&gt; char oper = '+';&gt; switch (oper)&#123;&gt; case '+':&#123;&gt; System.out.println("x + y =" + (x + y));&gt; &#125;&gt; case '-':&#123;&gt; System.out.println("x - y =" + (x - y));&gt; &#125;&gt; case '*':&#123;&gt; System.out.println("x * y =" + (x * y));&gt; &#125;&gt; case '/':&#123;&gt; System.out.println("x / y =" + (x / y));&gt; &#125;&gt; default:&#123;&gt; System.out.println("未知操作！");&gt; &#125;&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; 最后得到的结果如下： 123456&gt; x + y =9&gt; x - y =-3&gt; x * y =18&gt; x / y =0&gt; 未知操作！&gt; &gt; 从运行的结果可以发现，程序在满足第一个条件后，由于没有设置break语句，所以从第一个满足条件的语句case开始依此向后继续执行，知道最后一个条件执行完毕。 循环结构while循环while是循环语句，也是判断语句，当事前不知道循环执行多少次时，就要用while循环，其格式如下： 1234567while (循环条件判断)&#123; 语句1; 语句2; ··· 语句n; 循环条件改变；&#125; 在while循环语句中，只有一个判断条件，当判断条件为真时，循环就会执行一次，再重复测试判断条件，执行循环主体，知道判断条件为假，才会跳出while循环。下面是while循环的流程及流程图： （1）第一次进入while循环前，必须先为循环控制变量（或表达式）赋起始值。 （2）根据判断条件的内容决定是否要继续执行循环，如果条件判断值为真（true），继续执行循环主体，若条件判断值为假（false），则跳出循环执行其他语句。 （3）执行完循环主体内的语句后，重新为循环控制变量（或表达式）赋值（增加或者减少），由于while循环不会自动更改循环控制变量（或表达式）的内容，所以while循环中为循环控制变量赋值的工作要自己来做，完成后再回到步骤（2）重新判断是否继续执行循环。 使用while循环进行累加操作： 1234567891011public class WhileDemo &#123; public static void main(String[] args) &#123; int x = 1; int sum = 0; while (x &lt;= 10) &#123; sum += x; x++; &#125; System.out.println("1--&gt;10累加结果为：" + sum); &#125;&#125; 程序运行结果为：1--&gt;10累加结果为：55 如果程序中没有修改循环条件（x++），那么程序将出现“死循环”的情况。 do···while循环do···while循环也是用于未知循环执行次数的情况，而while循环及do···while循环最大的不同就是进入while循环前，while语句会先测试判断条件的真假，再决定是否执行循环主体，而do···while循环则是每次都是先执行一次循环主体，然后再测试判断条件的真假，所以无论循环成立的条件是什么，使用do···while循环时，至少都会执行一次循环主体。do···while循环的格式如下： 1234567do&#123; 语句1; 语句2; ··· 语句n; 循环条件改变;&#125;while(循环条件判断) 下面描述的do···while循环的流程及流程图： （1）进入do···while循环前，要先为循环控制变量（或表达式）赋起始值。 （2）直接执行循环主体，循环主体执行完毕，才开始根据判断条件的内容决定是否继续执行循环，条件为真（true）时，继续执行循环主体；条件为假（false）时，则跳出循环，执行其他语句。 （3）执行完循环主体内的语句后，重新为循环控制变量（或表达式）赋值（增加或减少），由于do···while循环和while循环一样，不会自动更改循环控制变量（或表达式）的内容，所以在do···while循环中赋值循环控制变量的工作要由自己来做，然后再回到步骤（2）重新判断是否继续执行循环。 使用while循环进行累加操作： 1234567891011public class DoWhileDemo &#123; public static void main(String[] args) &#123; int x = 1; int sum = 0; do &#123; sum += x; x++; &#125;while (x &lt;= 10); System.out.println("1--&gt;10累加结果为：" + sum); &#125;&#125; 程序的运行结果为：1--&gt;10累加结果为：55 从程序的运行结果来看，while和do···while的结果是一样的，但是do···while与while循环不同的是do···while操作中就算条件不满足，也至少会执行一次，而while如果条件不满足，则一次也不会被执行。 for循环对于while和do···while两种循环来讲，操作时并不一定要明确地知道循环次数，而如果开发者已经明确地知道了循环次数，那么就可以使用另一种循环语句——for循环。for循环的格式如下： 12345for(赋值初值；判断条件；赋值增减量)&#123; 语句1; ··· 语句n;&#125; 下面是for循环的流程和流程图： （1）第一次进入for循环时，要为循环控制变量赋起始值。 （2）根据判断条件的内容检查是否继续执行循环，当判断条件为真（true）时，继续执行循环主体内的语句；判断条件为假（false）时，则会跳出循环，执行其他语句。 （3）执行完循环主体内的语句后，循环控制变量会根据增减量的要求更改循环控制变量的值，然后再回到步骤（2）重新判断是否继续执行循环。 使用for循环进行累加操作： 123456789public class ForDemo &#123; public static void main(String[] args) &#123; int sum = 0; for (int x = 1; x &lt;= 10; x++)&#123; sum += x; &#125; System.out.println("1--&gt;10累加结果为：" + sum); &#125;&#125; 程序的运行结果依旧如下：1--&gt;10累加结果为：55 循环的嵌套多个循环语句是可以嵌套操作的，例如下面要打印一个九九乘法表： 12345678910public class ForNestedDemo &#123; public static void main(String[] args) &#123; for (int i = 1; i &lt;= 9; i++)&#123; for (int j = 1; j &lt;= 9; j++)&#123; System.out.println(i + "*" + j + "=" + (i * j) + "\t"); // “\t”制表 &#125; System.out.println("\n"); // 换行 &#125; &#125;&#125; 程序说明： （1）i为外层循环的循环控制变量，j为内层循环的循环控制变量。 （2）当i为1时，符合外层for循环的判断条件（i&lt;9），进入另一个内层for循环体，由于是第一次进入内层循环，所以j的初值为1，符合内层for循环的判断条件（j&lt;=i）进入循环主体，输入ij的值（1\1=1），如果最后j的值任符合内层for循环的判断条件（j&lt;=i），则再次执行计算与输出的工作，直到j的值大于i时，离开内层for循环，回到外层循环。此时，i会加1成为2，符合外层for循环的判断条件，继续执行内层for循环主体，直到i的值大于9时离开嵌套循环。 循环的中断break语句break语句可以强迫程序中断循环，当程序执行到break语句时，即会离开循环，继续执行循环外的下一个语句，如果break语句出现在嵌套循环中的内层循环，则break语句只会跳出当前层的循环。下面用for循环为例，描述break语句的格式： 12345678for (初值赋值；判断条件；设增减量)&#123; 语句1； 语句2； ··· break； ··· // 若执行break语句，则此块的语句将不会被执行 语句n；&#125; 例如： 12345678910public class BreakDemo &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++)&#123; if (i == 3)&#123; break; &#125; System.out.println("i =" + i); &#125; &#125;&#125; 程序运行结果如下： 123i =0i =1i =2 从结果可以看出，当i=3时，判断语句满足，则执行了break语句跳出了整个循环，因此没有输出i=3。 continue语句continue语句可以强迫程序跳到循环的起始处，当程序运行到continue语句时，会停止运行剩余的循环主体，而是回到循环的开始处继续运行。下面以for循环为例，描述continue语句的用法： 12345678for (初值赋值；判断条件；设增减量)&#123; 语句1； 语句2； ··· continue ··· // 若执行continue语句，则此处将不会被执行 语句n；&#125; 例如： 12345678910public class ContinueDemo &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; if (i == 3)&#123; continue; &#125; System.out.println("i = " + i); &#125; &#125;&#125; 程序运行结果为： 123456789i = 0i = 1i = 2i = 4i = 5i = 6i = 7i = 8i = 9 从结果中可以发现，当i的值为3时，程序并没有输出，而是退回了循环判断处继续向下执行，所以continue只是中断了一次的循环操作。 另外，在循环语句中定义的变量属于局部变量，所谓的局部变量是指此变量只能在循环语句中使用，而在循环语句之外则无法使用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java笔记：运算符]]></title>
    <url>%2F2019%2F03%2F16%2FJava%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Java中的运算符表达式时Java的一种语句，它由操作数和操作符组成，操作数可以是常量、变量，也可以是方法，而运算符就是数学中的运算符号，如“+”、“-”、“*”、“/”等，在表达式（z+100）中，z和100都是操作数，“+”就是运算符。 Java提供了很多运算符，这些运算符除了做一般的数学运算之外，还可以做逻辑运算、位运算等。根据所使用类的不同，运算符可以分为赋值运算符、算术运算符、逻辑运算符、条件运算符以及括号运算符。 赋值运算符号想为各种不同数据类型的变量赋值时，就需要使用赋值运算符（=），等号（=）在Java中不是“等于”的意思，二十“赋值”的意思，例如： 12345678public class OperatorDemo01 &#123; public static void main(String[] args) &#123; int num = 22; System.out.println("第一次输出：num = " + num); num = num - 3; System.out.println("第二次输出：num = " + num); &#125;&#125; 第五行中，把num-3的值赋给了num，所以程序运行的结果如下： 12第一次输出：num = 22第二次输出：num = 19 当然，也可以将等号后面的值赋给其他变量，例如： 1int sum = num1 + num2; // num1与num2相加之后的值再赋给变量sum存放 一元运算符对于大部分表达式而言，运算符的前后都有操作数，但是一元运算符比较特别，它只需要一个操作数。下表列出了一元运算符的成员： 序号 一元运算符 描述 1 + 正号 2 - 负号 3 ! NOT，否 下面程序演示了3种一元运算符的使用： 12345678910public class OperatorDemo02 &#123; public static void main(String[] args) &#123; boolean b = false; // 定义boolean型数据 int x = 10; // 定义一个正数 int y = -30; // 定义一个负数 System.out.println("b = " + b + ", !b = " + !b); // 取反 System.out.println("x = " + x + ", -x = " + -x); // 使用负号 System.out.println("y = " + y + ", +y = " + +y); // 使用正号 &#125;&#125; 程序运行结果如下： 123b = false, !b = truex = 10, -x = -10y = -30, +y = -30 算术运算符常用的算术运算符如下表： 序号 算术运算符 描述 1 + 加法 2 - 减法 3 * 乘法 4 / 除法 5 % 取模（取余数） 程序中的运用如下： 1234567891011public class OperatorDemo03 &#123; public static void main(String[] args) &#123; int i = 10; int j = 3; System.out.println(i + "+" + j + "=" + (i + j)); // 加法操作 System.out.println(i + "-" + j + "=" + (i - j)); // 减法操作 System.out.println(i + "*" + j + "=" + (i * j)); // 乘法操作 System.out.println(i + "/" + j + "=" + (i / j)); // 除法操作 System.out.println(i + "%" + j + "=" + (i % j)); // 取模操作 &#125;&#125; 运行的结果如下： 1234510+3=1310-3=710*3=3010/3=310%3=1 关系运算符Java中经常会在if语句中使用关系运算符，具体格式如下： 123if (布尔表达式)&#123; 语句;&#125; 如果括号中的布尔表达式成立，就会执行{}中的语句；若是布尔表达式不成立了，则语句不会执行。常用的关系运算符如下表所示： 序号 关系运算符 描述 1 &gt; 大于 2 &lt; 小于 3 &gt;= 大于等于 4 &lt;= 小于等于 5 == 等于 6 != 不等于 需要注意的是，赋值运算符为等号（=），为了避免混淆，当使用关系运算符“等于”时，必须使用两个等号（==）表示。关系运算符在if语句中的使用如下： 12345678910111213public class OperatorDemo04 &#123; public static void main(String[] args) &#123; if (5 &gt; 2)&#123; // 判断5是否大于2 System.out.println("条件成立：5大于2"); &#125; if (true)&#123; // 判断是否为真 System.out.println("直接写的true"); &#125; if ((3 + 6) == (3 - 6)) &#123; // 判断计算结果内容是否相等 System.out.println("这是不可能成立的！"); &#125; &#125;&#125; 程序运行结果如下： 12条件成立：5大于2直接写的true 可以看到程序中最后一个if语句内的内容没有执行，因为if语句中的条件满足了，才会执行if中的内容，否则不执行。另外如果if语句之中只有一条语句，那么可以不用写“{}”，但是不建议这么写。 自增与自减运算符 序号 自增与自减运算符 描述 1 ++ 自增，变量值加1 2 — 自减，变量值减1 用自增与自减运算符可以使程序更加简洁欸，例如，声明一个int类型的变量a，在程序运行中想让它加1，语句如下： 1a = a+1; // a加1后再赋值给a 将a的值加1后再赋给a存放，也可以利用自增运算符“++”写出语义相同但是语句更简洁的语句： 1a++; // a加1后再赋值给a存放，语句更简洁 在程序中还可以看到另一种自增运算符“++”的用法，就是将自增运算符“++”写在变量的前面，如++a，这就和a++所表示的意义完全不一样。a++会先执行整个语句后再将a的值加1，而++b则先把b的值加1后，再执行整个语句。 1234567891011121314public class OperatorDemo05 &#123; public static void main(String[] args) &#123; int a = 3, b = 3; int x = 6, y = 6; System.out.println("a = " + a); // 输出变量a的值 System.out.println("\t a++ = " + (a++) + ", a = " + a); // 先执行后自增 System.out.println("b = " + b); // 输出变量b的值 System.out.println("\t ++b = " + (++b) + ", b = " + b); // 先自增后执行 System.out.println("x = " + x); // 输出变量x的值 System.out.println("\t x-- = " + (x--) + ", x = " + x); // 先执行后自减 System.out.println("y = " + y); // 输出变量y的值 System.out.println("\t --y = " + (--y) + ", y = " + y); // 先自减后执行 &#125;&#125; 程序运行结果如下： 12345678a = 3 a++ = 3, a = 4b = 3 ++b = 4, b = 4x = 6 x-- = 6, x = 5y = 6 --y = 5, y = 5 逻辑运算符使用逻辑运算符可以连接多个逻辑运算，常用的逻辑运算符如下表： 序号 逻辑运算符 描述 1 &amp; AND，与 2 &amp;&amp; 短路与 3 &#124; OR，或 4 &#124;&#124; 短路或 当使用逻辑运算符“&amp;&amp;”时，运算符前后的两个操作数的返回值皆为真，运算的结果才会为真；使用逻辑运算“||”时，运算符前后的两个操作数的返回值只要有一个为真，运算结果就为真。并存在以下规律： 12345678910public class OperatorDemo06 &#123; public static void main(String[] args) &#123; boolean a = true; boolean b = false; System.out.println("a || b = " + (a || b)); System.out.println("a | b = " + (a | b)); System.out.println("a &amp;&amp; b = " + (a &amp;&amp; b)); System.out.println("a &amp; b = " + (a &amp; b)); &#125;&#125; 程序运行结果为： 1234a || b = truea | b = truea &amp;&amp; b = falsea &amp; b = false 根据对逻辑操作理解，可以总结以下规律： 对于与操作来说，如果第一个条件为假，后面的条件不管是真是假，最终的结果都是假。 对于或操作来说，如果第一个条件为真，后面的条件不管是真是假，最终的结果都是真。 也就是说，对于与和或来说，最先满足的条件就是一个关键性的条件，所以在Java中设置了短路与和短路或，对于短路与和与、短路或和或有以下区别： 对于与来说，要求所有的条件都判断，而如果使用短路与，第一个条件又为false，则后面的条件不需要再判断。 对于或来说，要求所有的条件都判断，而如果使用短路或，第一个条件又为true，则后面的条件不需要再判断。 下面通过三段代码来理解以上两点： 测试代码（一）：观察被除数为0的情况 123456public class OperatorDemo07 &#123; public static void main(String[] args) &#123; int x = 10 / 0; System.out.println("x = " + x); // 错误，被除数为0 &#125;&#125; 该段程序运行之后会出现以下错误，即错误的根本原因在于除数为0： Exception in thread “main” java.lang.ArithmeticException: / by zero 测试代码（二）：验证“&amp;”的作用 1234567public class OperatorDemo08 &#123; public static void main(String[] args) &#123; if (10 != 10 &amp; 10 /0 == 0) &#123; // 非短路与 System.out.println("条件满足"); &#125; &#125;&#125; 程序运行后，又出现了下面的错误提示： Exception in thread “main” java.lang.ArithmeticException: / by zero 造成以上错误的根本原因在于“与”操作要把所有的条件进行判断，所以在计算10/0时就出现了错误。 测试代码（三）：验证“&amp;&amp;”的作用 1234567public class OperatorDemo09 &#123; public static void main(String[] args) &#123; if (10 != 10 &amp;&amp; 10/0 == 0) &#123; // 短路与 System.out.println("条件满足"); &#125; &#125;&#125; 该程序运行后，没有出现上面的错误，因为短路与判断第一个条件就为false，那么之后的条件就不用判断了，这就是短路与的作用。短路或和或也是同样的原理。 括号运算符括号“()”也是Java的运算符，用于提高括号中表达式的优先级。 位运算符Java中支持位运算操作，位运算操作是指进行二进制位的运算，在Java中支持的位运算符如下表所示： 序号 位运算符 描述 1 &amp; 按位与 2 &#124; 按位或 3 ^ 异或（相同为0，不同为1） 4 ~ 取反 5 &lt;&lt; 左移位 6 &gt;&gt; 右移位 7 &gt;&gt;&gt; 无符号右移位 在Java中所有的数据都是以二进制的形式进行运算的，每一位二进制进行与、或、异或操作的结果如下表所示： 序号 二进制数1 二进制数2 与操作（&amp;） 或操作（&#124;） 异或操作（^） 1 0 0 0 0 0 2 0 1 0 1 1 3 1 0 0 1 1 4 1 1 1 1 0 下面通过一段代码来观察位运算符： 123456789public class OperatorDemo10 &#123; public static void main(String[] args) &#123; int x = 3; // 3的二进制数据：00000000 00000000 00000000 00000011 int y = 6; // 6的二进制数据：00000000 00000000 00000000 00000110 System.out.println(x &amp; y); // 与操作的结果： 00000000 00000000 00000000 00000010 System.out.println(x | y); // 或操作的结果： 00000000 00000000 00000000 00000111 System.out.println(x ^ y); // 异或操作结果： 00000000 00000000 00000000 00000101 &#125;&#125; 运行结果如下：123275 在计算机的数据表示中只定义了整数的表现形式，并没有定义负数的表现形式，所以，负数一般用补码的形式表示，整数的原码、反码、补码都相同，负数的反码除符号位为1外，其余位取相反；补码就是“反码+1”。 求出负数的反码： 123456public class OperatorDemo16 &#123; public static void main(String[] args) &#123; int x = -3; // -3的二进制数据：11111111 11111111 11111111 11111101 System.out.println(x + "的反码时：" + ~x); &#125;&#125; 程序输出的结果位2（二进制数据：00000000 00000000 00000000 00000010），因为计算机中负数都是使用补码的形式计算，补码的计算是“反码+1”，然后对-3进行反码，操作过程如下所示： 123410000000 00000000 00000000 00000011 // -3原码11111111 11111111 11111111 11111100 // -3反码11111111 11111111 11111111 11111101 // -3补码 = -3反码 + 100000000 00000000 00000000 00000010 // ~-3 在Java中也提供了左移“&lt;&lt;”和右移“&gt;&gt;”两种操作。左移操作是将运算数的二进制嘛整体左移指定位数，左移之后的空位由0来填充，例如： 123456public class OperatorDemo17 &#123; public static void main(String[] args) &#123; int x = 3; // 3的二进制数据： 00000000 00000000 00000000 00000011 System.out.println(x + "左移2位之后的内容：" + (x &lt;&lt; 2)); &#125;&#125; 程序输出为： 13左移2位之后的内容：12 // 12二进制数：00000000 00000000 00000000 00001100 右移操作“&gt;&gt;”是将运算数的二进制码整体右移，右移之后的空位以符号位填充，即如果整数就用0填充，如果是负数则用1填充，例如： 12345678public class OperatorDemo18 &#123; public static void main(String[] args) &#123; int x = 3; // 3的二进制数据：00000000 00000000 00000000 00000011 int y = -3; // -3的二进制数： 11111111 11111111 11111111 11111101 System.out.println(x + "右移2位之后的内容：" + (x &gt;&gt; 2)); System.out.println(y + "右移2位之后的内容：" + (y &gt;&gt; 2)); &#125;&#125; 程序运行结果： 123右移2位之后的内容：0 // 3右移两位之后的二进制：00000000 00000000 00000000 00000000-3右移2位之后的内容：-1 // -3右移两位后的二进制： 11111111 11111111 11111111 11111111 因为-3右移后的二进制依然是负数，负数用的补码表示，而补码=反码+1，所以求出对应的反码=补码-1，原码也可以根据反码求出： -3右移两位后的二进制补码：11111111 11111111 11111111 11111111 反码 = 补码-1，即补码为： 11111111 11111111 11111111 11111110 -3右移两位后的二进制原码：10000000 00000000 00000000 00000001 以上右移操作是带符号位的右移操作，Java也提供无符号位的右移操作“&gt;&gt;&gt;”，即右移后的空位由0来填充，例如： 12345678public class OperatorDemo19 &#123; public static void main(String[] args) &#123; int x = 3; // 3的二进制数据：00000000 00000000 00000000 00000011 int y = -3; // -3的二进制数： 11111111 11111111 11111111 11111101 System.out.println(x + "右移2位后的内容：" + (x &gt;&gt;&gt; 2)); System.out.println(y + "右移2位后的内容：" + (y &gt;&gt;&gt; 2)); &#125;&#125; 程序运行结果： 123右移2位后的内容：0 // 3右移两位之后的二进制：00000000 00000000 00000000 00000000-3右移2位后的内容：1073741823 // 不带符号位-3右移两位： 00111111 11111111 11111111 11111111 运算符的优先级 优先级 运算符 类 结合性 1 () 括号运算符 由左至右 1 [] 方括号运算符 由左至右 2 !、+（正号）、-（负号） 一元运算符 由右至左 2 ~ 位逻辑运算符 由右至左 2 ++、— 自增与自减运算符 由右至左 3 *、/、% 算术运算符 由左至右 4 +、- 算术运算符 由左至右 5 &lt;&lt;、&gt;&gt; 位左移、位右移运算符 由左至右 6 &gt;、&gt;=、&lt;、&lt;= 关系运算符 由左至右 7 ==、!= 关系运算符 由左至右 8 &amp;（位运算符AND） 位逻辑运算符 由左至右 9 ^（位运算符XOR） 位逻辑运算符 由左至右 10 &#124;（位运算符OR） 位逻辑运算符 由左至右 11 &amp;&amp; 逻辑运算符 由左至右 12 &#124;&#124; 逻辑运算符 由左至右 13 ?: 三目运算符 由右至左 当使用同一级运算符的时候，结合性非常重要，因为它决定了谁会被先处理，即在相同优先级的运算符中，根据结合性来处理操作数。对于以上优先级没有必要完全记下，可以多使用括号改变优先级。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java数据类型]]></title>
    <url>%2F2019%2F03%2F15%2FJava%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[数据类型划分Java的数据类型可以分为基本数据类型和应用数据类型两类，原始数据类型也称为基本数据类型，包括最基本的boolean、byte、char、short、int、long、float、与double等类型；引用数据类型以一种特殊的方式指向变量的实体，类似于C/C++的指针，这类变量在声明时不会分配内存，必须另外开辟内存空间的操作，如字符串和数组均属于这种数据类型。Java的数据类型如下图所示： f(n) \begin{cases} 基本数据类型 \begin{cases} 数值型 \begin{cases} 整数类型（byte、short、int、long）\\ 浮点类型（float、double） \end{cases}\\ 字符型(char)\\ 布尔型（boolean） \end{cases}\\ 引用数据类型 \begin{cases} 类（class）\\ 接口（interface）\\ 数组 \end{cases} \end{cases}基本数据类型Java中基本的数据类型如下表所示： 序号 数据类型 大小/位 1 long（长整数） 64 2 int（整数） 32 3 short（短整数） 16 4 byte（位） 8 5 char（字符） 16 6 float（单精度） 32 7 double（双精度） 64 8 Boolean（布尔） — 整数类型整数类型可以分为long、int、short、及byte 4种，其中long为64位，即8个字节（bytes），int为32位，即4个字节，short为16位，也就是2个字节，byte为8位，也就是1个字节。例如，sum是一个短整型变量，在程序中作出如下声明： 1short num; //声明sum为短整型 经过声明之后，Java会在可使用的内存空间中寻找一个占有两个字节的块供sum变量使用。在Java中对于一个整型常量，其默认类型为int型，所以一般在声明常量时不要超过int数据类型的范围。 数据溢出当整数的数据大小超过其类型可以表示的范围，而程序中又没有做数值范围的检查时，一个整型变量所输出的值将会发生紊乱，且不是预期的运行结果。例如下面的程序中声明了一个整型的数，并把它赋值为整型所可以表示范围的最大值，然后将它分别加1和加2： 12345678class DataDemo01&#123; public static void main(String[] args)&#123; int max = Integer.MAX_VALUE; // 得到整型的最大值 System.out.println("整型的最大值：" + max); // 输出最大值 System.out.println("整型最大值 + 1：" + (max + 1)); // 最大值加1 System.out.println("整型最大值 + 2：" + (max + 2)); // 最大值加2 &#125;&#125; 程序的运行结果如下： 123整型的最大值：2147483647整型最大值+1：-2147483648整型最大值+2：-2147483647 int型的范围为-2147483648~2147483647，从输出结果可以看出，当最大值2147483647加上1之后，结果变成了最小值；当最大值加上2时，结果变成了次小值，这就是数据类型的溢出。为了避免int类型的溢出，可以再该表达式中的任一常量后加上大写的L，或者在变量前面加上long，做强制类型的转换，例如： 123456789ublic class DataDemo02 &#123; public static void main(String[] args)&#123; int max = Integer.MAX_VALUE; // 整型最大值 System.out.println("整型的最大值：" + max); // 输出最大值 System.out.println("整型最大值+1：" + (max+1)); // 最大值加1 System.out.println("整型最大值+2：" + (max+2L)); // 变成long型 System.out.println("整型最大值+2：" + ((long)max+2)); // 转换成long型 &#125;&#125; 程序运行的结果如下： 1234整型的最大值：2147483647整型最大值+1：-2147483648整型最大值+2：2147483649整型最大值+2：2147483649 处理int型的溢出，可以采用强制类型转换方式，但是对于long型的溢出，就没有处理办法了，此时就需要在程序中加上变量值的界限检查，在运行时才不会发生错误。 字符类型字符类型在内存中占两个字节，可以用来保存英文字母等字符。给字符变量赋值可以使用数字和字符，它们都能使程序正确的运行，例如，Java中使用Unicode编码系统，Unicode中小写的a是以97表示的，所以，如果要给一个字符变量赋值为a，可以使用小写“a”，也可以使用数字97，需要注意的是，字符要用一队单引号（’ ‘）括起。程序中字符类型的声明如下： 1char ch = 'a'; // 声明ch为字符型，其值为a 在程序中输出一个包括双引号的字符串时，可以把字符变量赋值为转义字符，再将它输出，即：再程序中声明一个字符类型变量ch，然后把ch设置为“\\””，再进行输出操作，或者，也可以直接再要输出的字符穿中加入特殊的转义字符。常用的转义字符如下表： 序号 转义字符 描述 1 \f 换页 2 \\ 反斜线 3 \b 倒退一格 4 \’ 单引号 5 \r 归位 6 \” 双引号 7 \t 制表符Tab 8 \n 换行 例如： 123456789public class DataDemo03 &#123; public static void main(String[] args) &#123; char ch1 = '\"'; // 定义转义字符 char ch2 = '\\'; // 定义转义字符 System.out.println("ch1 = " + ch1); // 打印输出 System.out.println("ch2 = " + ch2); // 打印输出 System.out.println("\"Hello World\""); // 直接输出转义字符 &#125;&#125; 程序输出如下： 123ch1 = &quot;ch2 = \&quot;Hello World&quot; 浮点数类型与双精度浮点数类型在Java中，带有小数点的数据类型称为浮点数类型（float），其长度为32个字节，当浮点数的表示范围不够大时，还有一种双精度（double）浮点数可以使用，双精度浮点数类型的长度为64个字节。两种数据类型的声明如下： 12double num; // 声明num为双精度浮点型变量float sum = 3.0f； // 声明sum为浮点型变量，其初值为3.0 需要注意的是，在Java中使用浮点型数值时，默认类型时double，在数值后面可以加上D或者d，作为double类型的标识，在数据后面加上F或者f，则作为float类型的标识。若什么都没加，Java会将该数据默认为double类型。 布尔类型布尔（boolean）类型的变量只有true（真）和false（假）两种，程序中对布尔类型的数据声明如下： 1boolean flag = true; // 声明布尔变量flag，并赋值为true 数据类型转换数据类型的转换方式可以分为自动类型转换及强制类型转换两种。 自动转换在程序中已经定义好了数据类型的变量，若要用另一种数据类习表示时，Java会在下列条件皆成立时，自动做数据类型的转换： ​ （1） 转换前的数据类型与转换后的类型兼容。 ​ （2） 转换后的数据类型的表示范围比转换前的类型大。 例如，将short类型的变量a转换成int类型，由于short与int皆为整数类型，符合上述条件（1）；而int的表示范围比short大，符合条件（2），因此Java会自动将原为short类型的变量a转换成int类型。 值得注意的是，类型的转换只限该行语句，并不会影响原先所定义的变量的类型，而且通过自动类型的转换可以保证数据的精确度，它不会因为转换而损失数据内容，这种类型的转换方式也称为扩大转换。 以扩大转换来看，字符和整数是可以使用自动类型转换的，整数和浮点数亦是兼容的，但是由于boolean类型只能存放true或false，与整数及字符是不兼容的，因此不能做类型的转换。下面介绍当两个数其中一个为浮点数时，其运算结果会怎么变化： 123456789public class DataDemo04 &#123; public static void main(String[] args) &#123; int x = 30; float y = 22.19f; System.out.println(&quot;x/y = &quot; + (x/y)); System.out.println(&quot;10/3.5 = &quot; + (10/3.5)); System.out.println(&quot;10/3 = &quot; + (10/3)); &#125;&#125; 程序运行结果为： 123x/y = 1.351960310/3.5 = 2.85714285714285710/3 = 3 从输出结果来看，int类型与float类型进行计算之后，输出的结果会变成float类型，一个整型常量和一个浮点型常量进行计算之后，结果也会变成一个浮点数据，而如果两个int型的常量进行计算，最终结果也时int型，而其小树部分将会被忽略。也就是说，假设有一个整数和双精度浮点数作运算时，Java会把整数转换成双精度浮点数后再做运算，运算结果也会变成双精度浮点数。 强制转换当两个整数进行运算时，其运算结果也会是整数，例如，做除法运算8/3，其结果为整数2，而不是实际的2.33333···，因此，在Java中若是想要得到的计算结果是浮点数时，就必须将数据类型做强制性的转换，转换语法如下： 1（要转换的数据类型） 变量名称； 因为这种强制类型的转换时直接变写在程序代码中的，所以也称为显示转换。强制转换例子如下： 12345678public class DataDemo05 &#123; public static void main(String[] args) &#123; float f = 30.3f; int x = (int)f; System.out.println("x = " + x); System.out.println("10 / 3 = " + ((float)10 /3 )); &#125;&#125; 程序运行结果如下： 12x = 3010 / 3 = 3.3333333 在程序中，首先将一个浮点型的变量f的内容赋给了int型变量x，因为int数据类型的长度小于float类型的长度，所以此处需要进行强制转换。程序的最后使用了两个整型常量进行计算，但是因为将其中一个整型变量变为了float类型，所以在计算时会强制把其他的整型也变成float类型，最后计算结果也就是包含小数的。 和自动转换一样，强制转换并不会影响原先定义的变量的类型，运行时只会将强制转换的那行语句进行变量的数据类型转换。此外，若是将一个超出该变量可表示范围的值赋值给这个变量，这种转换称为缩小转换，这种转换可能会丢失数据精度，因此Java并不会主动进行这种类型的转换，此时就必须做强制转换。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
</search>
