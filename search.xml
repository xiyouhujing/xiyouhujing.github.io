<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[通信原理笔记（一）]]></title>
    <url>%2F2019%2F11%2F18%2F%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[通信系统的组成通信系统一般模型对于电通信来说，首先要把消息转变成电信号，然后经过发送设备，将信号送入信道，在接收端利用接收设备对接收信号作相应的处理后，送给信宿再转换为原来的消息。这个过程可以用下图所示的通信系统一般模型来概括。 1、信息源 信息源简称信源，其作用是把各种消息转换成原始电信号，根据消息的种类不同，信源可以分为模拟信源和数字信源。模拟信源输出连续的模拟信号，如话筒（声音-音频信号）、摄像机（图像-视频信号）；数字信源则输出离散的数字信号，如电传机（键盘字符-数字信号）、计算机等各种数字终端。并且，模拟信源送出的信号经数字化处理后也可以发送数字信号。 2、发送设备 发送设备的作用是生产适合于在信道中传输的信号，即使发送信号的特性和信道特性相匹配，具有抗信道干扰的能力，并且具有足够的功率以满足远距离传输的需要。因此，发送设备涵盖的内容很多，可能包含变换、放大、滤波、编码、调制等过程。对于多路传输系统，发送设备中还包括多路复用器。 3、信道 信道是一种物理媒质，用来将来自发送设备的信号传送到接收端。在无线信道中，信道可以是自由空间；在有线信道中看，可以是明线、电缆和光纤。信道即给信号以通路，也会对信号产生各种干扰和噪声。 上图中的噪声源是信道中的噪声及分散在通信系统其他各处的噪声的集中表示。噪声通常是随机的，形式多样的，它的出现干扰了正常的信号的传输。 4、接收设备 接收设备的功能是将信号放大和反变换（如译码、调解等），其目的是从受到减损的接收信号中正确恢复出原始电信号，对于多路复用信号，接收设备中还包括解除多路复用，实现正确分路的功能，此外，它还要尽可能减小在传输过程中噪声与干扰所带来的影响。 5、受信者 受信者简称信宿是传送消息的目的地，其功能与信源相反，即把原始电信号还原成相应的消息，如扬声器等。 模拟通信系统模型和数字通信系统模型通信传输的消息是多种多样的，大致可以分为两大类：一类为连续消息；另一类称为离散消息。连续消息是指消息的状态连续变化或不可数的，例如连续变化的话音、图像等；离散消息则是指消息的状态是可数的或离散的，如符号、数据等。 消息的传递时通过它的物理载体——电信号来实现的，即把消息寄托在电信号的某一参量上（如连续波的幅度、频率或相位；脉冲波的幅度、宽度或位置）。按信号参量的取值方式不同，可以把信号分为两类：模拟信号和数字信号。如果电信号的参数取值连续（不可数、无穷多），则称之为模拟信号，模拟信号有时也称为连续信号，这里连续的含义时指某信号的某一参量连续变化，或者说在某一取值范围内可以取无穷多个值，而不一定在时间上也连续；如果电信号的参量仅可能取有限个值，则称之为数字信号，数字信号有时也称为离散信号，这个离散是指信号的某一参量是离散变化的，而不一定在时间上也离散。 通常，按照信道中传输的是模拟信号还是数字信号，相应地把通信系统分为模拟通信系统和数字通信系统。 1、模拟通信系统模型 模拟通信系统是利用模拟信号来传递信息的通信系统，其模型如下图所示，其中包含了两种重要变换。第一种变换是，在发送端把连续消息变换成原始电信号，在接收端进行相反的变换]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>通信原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django开发大型企业网站]]></title>
    <url>%2F2019%2F11%2F15%2FDjango%E5%BC%80%E5%8F%91%E5%A4%A7%E5%9E%8B%E4%BC%81%E4%B8%9A%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LNMP环境搭建及zabbix服务搭建配置]]></title>
    <url>%2F2019%2F10%2F18%2FLNMP%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8Azabbix%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[LNMP环境搭建环境说明：OS： centos7.7_x64 nginx： nginx-1.8.0 php： php-5.6.28 mysql： mysql-5.7.28 zabbix：zabbix-3.4.3 安装前准备关闭防火墙和selinux# systemctl status firewalld //查看防火墙状态 # systemctl stop firewalld //停止防火墙 # systemctl disable firewalld.service //禁止开机启用防火墙 # vi /etc/selinux/config //进入配置文件 设置：SELINUX=disabled（重启才生效） 准备yum源# wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo # yum -y install epel-release 安装依赖关系# yum install pcre* //为了支持rewrite功能 # yum install openssl openssl-devel #yum install gcc make gd-devel libjpeg-devel libpng-devel libxml2-devel bzip2-devel libcurl-devel -y //编译需要的依赖包 nginx安装下载安装包# wget http://nginx.org/download/nginx-1.8.0.tar.gz 编译安装# tar –zxvf nginx-1.8.0.tar.gz -C /usr/local //解压nginx到/usr/local路径下 # cd /usr/local/nginx-1.8.0/ #./configure —user=nobody —group=nobody —prefix=/usr/local/nginx —with-http_stub_status_module —with-http_gzip_static_module —with-http_realip_module —with-http_sub_module —with-http_ssl_module # make &amp;&amp; make install 启动nginx服务# /usr/local/nginx/sbin/nginx 打开浏览器访问此机器的 IP，如果浏览器出现 Welcome to nginx! 则表示 Nginx 已经安装并运行成功。 编辑nginx主配置文件# vi /usr/local/nginx/conf/nginx.conf 主要对server项做如下的改动： ​ server { ​ listen 80; ​ server_name localhost; ​ location / { ​ root /usr/local/nginx-1.8.0/html/; ​ index index.html index.htm index.php; ​ autoindex on; ​ } autoindex on; ​ autoindex_exact_size on; autoindex_localtime on; ​ location ~ .php$ { ​ root /usr/loca/nginx-1.8.0/html; ​ fastcgi_pass 127.0.0.1:9000; ​ fastcgi_index index.php; ​ fastcgi_param SCRIPT_FILENAME /usr/local/nginx-1.8.0/html$fastcgi_script_name; ​ # fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; ​ include fastcgi_params; ​ } } 重启nginx# /usr/local/nginx/sbin/nginx –s reload 安装mysql下载和安装mysql5.7# wget http://dev.mysql.com/get/mysql57-community-release-el7-7.noarch.rpm # yum localinstall mysql57-community-release-el7-7.noarch.rpm # yum repolist enabled | grep “mysql.-community.“ # yum install mysql-community-server # systemctl start mysqld.service # grep ‘temporary password’ /var/log/mysqld.log //记录随机密码 # mysql_secure_installation //初始化 # mysql -u root –p //用随机密码登陆 新建以及初始化数据库zabbix> create database zabbix character set utf8;; > use zabbix; > source /root/zabbix-3.4.3/database/mysql/schema.sql; // 在安装完zabbix后的操作 > source /root/zabbix-3.4.3/database/mysql/data.sql; // 在安装完zabbix后的操作 > source /root/zabbix-3.4.3/database/mysql/images.sql; // 在安装完zabbix后的操作 安装php安装依赖扩展包# yum -y install libmcrypt libmcrypt-devel mhash mhash-devel mcrypt libxml2-devel bzip2-devel libcurl-devel libjpeg-devel libpnglibpng-devel freetype freetype-devel libmcrypt libmcrypt-devel 下载php# wget http://php.net/get/php-5.6.28.tar.gz/from/this/mirror -O php-5.6.28.tar.gz 编译安装php# tar –zxvf php-5.6.28.tar.gz # cd php-5.6.28 # ./configure -prefix=/usr/local/php -with-config-file-path=/usr/local/php/etc -with-bz2 -with-curl -enable-ftp -enable-sockets -disable-ipv6 -with-gd -with-jpeg-dir=/usr/local -with-png-dir=/usr/local -with-freetype-dir=/usr/local -enable-gd-native-ttf -with-iconv-dir=/usr/local -enable-mbstring -enable-calendar -with-gettext -with-libxml-dir=/usr/local -with-zlib -with-pdo-mysql=mysqlnd -with-mysqli=mysqlnd -with-mysql=mysqlnd -with-ldap -enable-dom -enable-xml -enable-fpm -with-libdir=lib64 -enable-bcmath # make &amp;&amp; make install 准备php和php-fpm的配置文件编辑php-5.6.28解压文件下的php.ini-production # vi /php-5.6.28/ php.ini-production 修改如下参数： max_execution_time = 300 memory_limit = 128M ​ post_max_size = 16M ​ upload_max_filesize = 2M ​ max_input_time = 300 ​ date.timezone = PRC # cp /php-5.6.28php.ini-production /usr/local/php/etc/php.ini # cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf 编辑php-fpm的配置文件# /usr/local/php/etc/php-fpm.conf 取消pid的注释： …… [global] pid = run/php-fpm.pid …… 启动php-fpm，占用端口9000# /usr/local/php/sbin/php-fpm 测试php在/usr/local/nginx-1.8.0/html/目录下新建test.php： vi /usr/local/nginx-1.8.0/html/test.php 内容如下： ​ &lt;?php ​ phpinfo(); ​ ?&gt; 重启nginx： # /usr/local/nginx/sbin/nginx -s reload 在浏览器中输入：http://192.168.112.101/test.php ，出现以下画面则说明配置php成功 zabbix server安装与配置安装zabbix安装依赖包# yum install mysql-devel –y 如果编译遇到mysql文件冲突，则可能是版本冲突，使用rpm下载： # wget ftp://ftp.pbone.net/mirror/dev.mysql.com/pub/Downloads/MySQL-5.7/mysql-community-devel-5.7.25-1.el7.x86_64.rpm # yum localinstall mysql-community-devel-5.7.25-1.el7.x86_64.rpm # yum install net-snmp-devel –y # yum install libevent-devel –y 下载zabbix# wget https://nchc.dl.sourceforge.net/project/zabbix/ZABBIX%20Latest%20Stable/3.4.3/zabbix-3.4.3.tar.gz 编译安装zabbix# tar –zxvf zabbix-3.4.3 # cd zabbix-3.4.3 #./configure —prefix=/usr/local/zabbix —with-mysql —with-net-snmp —with-libcurl —enable-server —enable-agent —enable-proxy # make &amp;&amp; make install 安装完成后记得回到数据库安装步骤，导入数据库 配置server和agentd编辑zabbix_server.confvi /usr/local/zabbix/etc/zabbix_server.conf 做如下的改动： ​ DBName=zabbix ​ DBUser=root // 如果给zabbix数据库创建了用户，则改为zabbix数据库用户 ​ DBPassword=123456 // zabbix数据库的密码 ​ DBPort=3306 编辑zabbix_agentd.confvi /usr/local/zabbix/etc/zabbix_agentd.conf 做如下改动： ​ Server=127.0.0.1 ​ ServerActive=127.0.0.1 ​ Hostname=Zabbix server 配置nginx zabbix拷贝zabbix前端文件到nginx的html文件夹中： # cp -r /root/zabbix-3.4.3/frontends/php/* /usr/local/nginx-1.8.0/html/zabbix # chmod –R 777 /usr/local/nginx-1.8.0/html 启动zabbix server和zabbix agent# /usr/local/zabbix/sbin/zabbix_server # /usr/local/zabbix/sbin/zabbix_agentd 界面配置zabbix使用浏览器访问http://192.168.112.101/zabbix/setup.php 在检测信息时，可查看具体的报错信息对/usr/local/php/etc/php.ini文件进行编辑解决 对应/usr/local/zabbix/etc/zabbix_server.conf文件填写数据库名称、用户和密码： host与port不需要修改，name自定义 确认信息,正确点击下一步 根据以下页面的提示下载配置文件，并将配置文件保存到/usr/local/nginx-1.8.0/html/zabbix/conf/zabbix.conf.php，点击“完成” 配置完成后进入登陆页面，默认登陆名为：admin，密码为：zabbix 在跳转的页面中点击右上角的小人头像可以设置web页面的语言： 添加监控信息修改监控管理机zabbix server：配置&gt;&gt;主机&gt;&gt;Zabbix server 主机名称： 要与主机名相同，这是zabbix server程序用的 可见名称： 显示在zabbix网页上的，给我们看的 修改后，要将下面的已启用要勾上。添加完成就有了管理机的监控主机，注意ZBX要显示为绿色 监控客户机的openssl版本客户机安装zabbix agent安装依赖# yum -y install net-snmp-devel libxml2-devellibcurl-deve libevent libevent-devel 安装zabbix agent# yum install zabbix-agent –y 编辑配置文件# vi /etc/zabbix/zabbix_agentd.conf 修改server、hostname、serveractive信息： Server=192.168.112.101 //zabbix server的ip ServerActive=192.168.112.101 //和server相同 Hostname=centos6 //记住hostname，在zabbix server中添加主机时用到 启动zabbix agent# /usr/sbin/zabbix_agentd zabbix server添加监控主机创建主机配置&gt;&gt;主机，主机名称与zabbix_agentd.conf中的一致，IP地址填写客户机的IP地址 客户端自定义监控项本次监控的是客户机上的openssl版本。 （1）查看客户端openssl版本： # yum info openssl 可以看到两组信息，一个是已安装的openssl软件包的信息，还有一组是可安装的openssl软件包的信息，其中，客户端已安装版本是1.0.1e，可安装版本是1.0.2k，我们需要让zabbix server自动监控客户端的openssl版本，并在版本较低时发出告警。 2）修改客户端配置文件zabbix_agentd.conf # vi /etc/zabbix/zabbix_agentd.conf 搜索 ‘UnsafeUserParameters’取消注释#号，将‘0’改为‘1’ Include=/etc/zabbix/zabbix_agentd.d/*.conf # cd cd /etc/zabbix/zabbix_agentd.d/ 自定义监控项的key值，格式为UserParameter=,，key值不能与现有的重复。 # vi userparameter_openssl.conf // 新建自定义监控项的配置文件，内容如下 UserParameter=openssl_version,yum info openssl|awk -F: ‘/^Version/{print $2;exit;}’ 其中openssl_version为key值，yum info openssl|awk -F: ‘/^Version/{print $2;exit;}’为获取openssl版本号的命令。 在server端配置（1）在zabbix服务端使用zabbix-get # yum install zabbix-get –y # zabbix_get -s 192.168.112.101 -p 10050 -k “openssl_version” 结果为： 其中-s参数指定客户端地址，-p指定端口，-k指定key值，这里获取到客户端的openssl版本号为1.0.1e。 （2）在zabbix的web界面添加自定义监控项 点击：配置&gt;&gt;主机&gt;&gt;监控项 在跳转的页面中点击“创建监控项”，跳转到如下界面，并添加监控项信息，其中的键值要去自定义的key值对应，即openssl_version，因为获取的是字符串，所以数据类型选择“字符”，更新时间间隔，历史数据保留时长等根据所添加的监控项合理设置，这里为了尽快看到数据，将更新时间设置为30秒。 在页面最后勾选“已启用”，点击“添加”。 点击：监测中&gt;&gt;最新数据&gt;&gt;监控项的历史记录，就可以看到监控的结果 （3）设置触发器 点击：配置&gt;&gt;主机&gt;&gt;触发器 在跳转的页面中点击右上角的“创建触发器”，在名称中填写告警的提示信息，严重性可以自己选择，这里选择的是“警告”，即如果监控到的客户机openssl版本与指定的版本不一致，将会出现名为“The openssl needsto be updated”的警告信息。 在表达式中填写规则，点击右侧的“添加”，在弹出的窗口中填入规则信息，监控项选择我们我们创建的监控项openssl，功能选择“查找字符串V的最近值……”，V则填写我们指定的openssl版本号，最后点击插入。 勾选页面下面的“已启用”，最后点击“添加”。 监控结果点击：检测中&gt;&gt;仪表盘，可以显示问题信息，由于我们客户机的openssl版本是1.0.1e，而我们指定的版本是1.0.2k，所以触发了“The openssl needs to be updated”的警告信息]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java开发环境配置]]></title>
    <url>%2F2019%2F09%2F27%2FJava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[下载安装JDK1.JDK是Java开发工具，下载地址为：https://www.oracle.com/technetwork/java/javase/downloads/index.html ，点击如下图片中的按钮： 2.在跳转的页面中选择接受许可，之后根据自己的系统选择对应的安装程序，本文window 64为例，如下： 3.双击安装文件，然后提示的安装步骤进行安装即可，可以修改JDK的安装路径，例如我的安装路径为：D:\JDK，记住安装路径，在接下来配置环境变量中需要用到。 配置环境变量1.安装完成后，邮件“我的电脑”/“此电脑”，点击“属性”，选择“高级系统设置”，如下图： 2.选择“高级”选项卡，点击“环境变量”，如下图： 3.在“系统变量”中分别设置JAVA_HOME、CLASSPATH、PATH三个属性，如果三个属性不存在，则新建，存在则选定后编辑，变量参数设置如下： 变量名 变量值 JAVA_HOME D:\JDK (根据自己的安装路径选择) CLASSPATH .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; （注意最前面有.; 符号用英文） PATH %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin （win10中双击PATH后分条添加，否则无法识别） 测试JDK是否安装成功1.ctrl+R，在弹出的对话框中输入cmd，回车。 2.在弹出的命令框中，输入java -version命令，如果出现如下结果，则说明java环境配置成功： 安装Eclipse目前市场上用于java开发的IDE比较多，比较推荐Eclipse和IntelliJ IDEA，IDEA功能很强大，但是要收费，Eclipse是免费开源的java开发工具，也是目前使用较多的开发工具，所以这里推荐安装Eclipse。 1.下载eclipse的安装文件，下载地址为：https://www.eclipse.org/downloads/packages/ ，选择Eclipse IDE for Committers，并根据自己的电脑系统选择相应的版本，本次选择windows 64： 2.在跳转的界面中，默认的下载地址是日本一所大学，此时点击“select another mirror”，然后将页面往下拉，选择中国的镜像，这样下载速度较快，这里选择大连东软信息学院或者中国科技大学镜像，如下： 3.选择镜像之后，开始下载，下载完成后的文件名为eclipse-committers-2019-09-R-win32-x86_64.zip，解压，运行eclipse.exe。按照步骤安装。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDK</tag>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JMeter安装与使用]]></title>
    <url>%2F2019%2F09%2F27%2FJMeter%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[介绍JMeter是基于Java的测试工具，主要对web应用和软件进行接口测试和压力测试。 安装前准备在安装配置JMeter之前，需要确定电脑是否安装有Java环境，可以利用命令提示符查验： 1.ctrl + R，之后输入cmd，在弹出的命令行窗口中输入java -veision，如果出现如下结果，则表明电脑中存在Java环境，接下来便可以进行JMeter的安装： 2.如果电脑中没有java环境，则首先要下载和配置java的开发工具包JDK，具体步骤参考：https://xiyouhujing.github.io/2019/09/27/Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/ Jmeter下载1.进入Jmeter官网http://jmeter.apache.org/，点击如下按钮： 2.在跳转的页面中选择版本下载，如图我选择下载的为zip压缩文件： 3.将下载下来的压缩文件解压，记住文件的路径，本文的路径为：D:\Jmeter\apache-jmeter-5.1.1。另外，因为下载下来的是jmeter5.1，需要注意的是对应的jdk版本不能太低。 Jmeter环境变量配置1.右键“我的电脑”/“此电脑”，点击“属性”，选择“高级系统设置”： 2.选择“高级”选项卡，点击“环境变量”： 3.在“系统变量”中，分别设置JMETER_HOME和CLASSPATH属性，如果属性不存在，则新建，存在则编辑，具体的参数如下： 变量名 变量值 JMETER_HOME D:\Jmeter\apache-jmeter-5.1.1 （jmeter的解压路径） CLASSPATH %JMETER_HOME%\lib\ext\ApacheJMeter_core.jar;%JMETER_HOME%\lib\jorphan.jar;%JMETER_HOME%\lib\logkit-2.0.jar; 测试是否安装配置成功1.进入jmeter的安装路径，进入bin文件夹，找到jmeter.bat： 2.双击jmeter.bat文件，此时会出现如下命令窗口，在jmeter工作期间，该窗口都不能关闭 3.以上窗口正常出现后，稍等片刻会出现jmeter的工作界面，如下图： 优化jmeter的使用1.我们发现，每次需要使用jmeter的时候必须进入它的安装文件，再进入bin文件，双击jmeter.bat，这么操作比较麻烦。因此我们可以将该文件发送到桌面生成快捷方式：右键jmeter.bat—&gt;发送到—&gt;桌面快捷方式。 2.如果觉得发送到桌面的快捷方式图标不好看，和桌面其他快捷方式格格不入，我们还可以修改该快捷方式的图标：右键该快捷方式，选择属性，在出现的窗口中选择“快捷方式”选项卡，点击下方的“更改图标”按钮，如下： 3.在弹出的窗口中可以选择系统自带的图标： 4.如果想自定义一个图标，可以网上下载一个自己喜欢的图标（ 1.ico ），保存为ico格式，点击“更改图标”窗口的浏览按钮，选择自己想要的图标，点击确定，图标修改完成。 5.如果使用默认的jmeter.bat启动的话，会出现一个CMD命令窗口之后再启动jmeter。如果不想每次点击jmeter的快捷方式都要打开命令窗口，可以进行如下修改： 右键jmeter.bat快捷方式，点击属性，修改目标和启始位置（根据实际的jmeter解压路径填写）： 目标：D:\Jmeter\apache-jmeter-5.1.1\bin\ApacheJMeter.jar 起始位置：D:\Jmeter\apache-jmeter-5.1.1\bin 注意：默认ApacheJMeter.jar的打开方式是解压工具winrar，这里需要更改打开方式 使用Jmeter进行测试更改JMeter默认语言点击【options】&gt;【choose language】变为简体中文，方便操作，如下图： 创建线程组1、在“测试计划”上右键，依次选择【添加】&gt;【线程（用户）】&gt;【线程组】 2、在线程组界面设置线程数和循环次数，我这里设置线程数为100，循环一次 添加HTTP请求默认值1、在刚刚创建的线程组上右键，依次选择【添加】&gt;【配置元件】&gt;【HTTP请求默认值】 2、在配置元件界面填写我们需要测试的程序协议、地址和端口，如下图所示： 构造HTTP请求1、在线程组上右键，依次选择【添加】&gt;【取样器】&gt;【HTTP请求】,如下图： 2、由于我们刚才在HTTP默认值中设置了默认路径，我们这里使用默认路径的话，就在http请求界面的路径中输入反斜杠“/”就行，如下图： 其中消息体数据根据实际情况填写，可以无参数。 添加HTTP请求头1、在线程组上右键，依次选择【添加】&gt;【配置元件】&gt;【HTTP信息头管理器】，如下图： 2、因为HTTP请求中没有传输数据，所以，这里设置为Content-Type:application/text（如果在HTTP请求中传入了数据，并且为json格式的数据，则可以设置为Content-Type:application/json） 添加断言1、在线程组上右键，依次点击【添加】&gt;【断言】&gt;【响应断言】，如下图： 2、根据响应的数据来判断请求是否正常。这里只判断的响应代码是否为200。还可以配置错误信息，如下图所示： 察看结果树1、在线程组上右键，依次选择【添加】&gt;【监听器】&gt;【察看结果树】 2、点击运行按钮便可查看结果]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>JMeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java笔记：this关键字]]></title>
    <url>%2F2019%2F06%2F05%2FJava%E7%AC%94%E8%AE%B0%EF%BC%9Athis%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[this是Java中的关键字，除了可以用来强调调用的是本类中的方法，this还有以下作用： 表示类中的属性 可以使用this调用本类的构造方法 this表示当前对象 使用this调用本类中的属性在程序中可以使用this调用本类属性，例如： 1234567891011class Person&#123; private String name; private int age; public Person(String n, int a)&#123; name = n; age = a; &#125; public String getInfo()&#123; return "姓名：" + name + "，年龄：" + age; &#125;&#125; 该类中的构造方法意在为类中的属性赋值，但是其实从构造方法传递的参数名称上很难看出n或者a表示的意义，所以进行如下的修改： 1234567891011class Person&#123; private String name; private int age; public Person(String name, int age)&#123; name = name; age = age; &#125; public String getInfo()&#123; return "姓名：" + name + "，年龄：" + age; &#125;&#125; 这个时候就能看出构造方法中两个参数表示的意思了，但是同时也出现了新的问题，构造方法的本意是要将参数传递的name赋值给类中的name属性，把age的值赋给age属性，但是实际运行出来的结果却和我们想像的并不一样，例如： 1234567891011121314151617class Person01&#123; private String name; private int age; public Person01(String name, int age)&#123; name = name; age = age; &#125; public String getInfo()&#123; return "姓名：" + name + "，年龄：" + age; &#125;&#125;public class ThisDemo01 &#123; public static void main(String[] args) &#123; Person01 per1 = new Person01("张三",33); System.out.println(per1.getInfo()); &#125;&#125; 程序运行结果为：姓名：null，年龄：0 从结果来看，程序并没有将构造方法传递进去的参数赋值给属性，也就是说，现在的构造方法并不能将传递进去的参数值赋给类中的熟悉你个，这是由于在赋值时，属性并没有被明确的指出，而这种错误可以利用this关键字来结果，例如进行如下的修改： 1234567891011121314151617class Person02&#123; private String name; private int age; public Person02(String name, int age)&#123; this.name = name; // 明确表示为类中的name属性赋值 this.age = age; // 明确表示为类中的age属性赋值 &#125; public String getInfo()&#123; return "姓名：" + name + "，年龄：" + age; &#125;&#125;public class ThisDemo02 &#123; public static void main(String[] args) &#123; Person02 per2 = new Person02("张三", 33); System.out.println(per2.getInfo()); &#125;&#125; 程序运行结果：姓名：张三，年龄：33 实际上上面程序中的“name = name”、“age = age”中的两个name和两个age都是构造方法中的参数。更实际中的就近原则相似，在程序的构造方法中，已经存在了name和age属性，那么在构造方法中如果要使用name或age属性，则肯定按照就近取用的原则，所以上面的name和age使用都是构造方法中的参数。 使用this调用构造方法如果一个类中有多个构造方法，也可以利用this关键字互相调用。 假设现在要求不管类中有多少个构造方法，只要对象一被实例化，就打印一行“一个新的对象被实例化”信息出来，很明显，如果在每个构造方法中编写此输出语句肯定不是最佳方法，所以可以利用this关键字完成，如下： 123456789101112131415161718192021class Person03&#123; private String name; private int age; public Person03()&#123; System.out.println("一个新的Person对象被实例化"); &#125; public Person03(String name, int age)&#123; this(); // 在此处调用Person类中的无参构造方法 this.name = name; // 为name属性赋值 this.age = age; // 为age属性赋值 &#125; public String getInfo()&#123; return "姓名：" + name + "，年龄：" + age; &#125;&#125;public class ThisDemo03 &#123; public static void main(String[] args) &#123; Person03 per1 = new Person03("张三", 33); System.out.println(per1.getInfo()); &#125;&#125; 程序运行结果： 12一个新的Person对象被实例化姓名：张三，年龄：33 该程序中提供了两个构造方法，其中有两个参数的构造方法中使用this()的形式调用该类中的无参构造方法，所以即使是通过有两个参数的构造方法实例化，最终结果还是会把无参构造方法中的内容打印出来。 另外需要注意的是，在使用this()调用构造方法的时候，由于构造方法是在实例化对象时被自动调用，也就是说在类中的所有方法中，只有构造方法是被优先调用的，所以使用this调用构造方法必须也只能放在构造方法的首行，下面就是一个错误的例子： 12345678910111213141516class Person&#123; private String name; private int age; public Person()&#123; system.out.println("一个新的Person对象被实例化。"); &#125; public Person(String name, int age)&#123; this.name = name; this.age = age; this(); // 错误的调用，只能放在构造方法的首行 &#125; public String getInfo()&#123; this(); // 错误的调用，只能放在构造方法的首行 return "姓名：" + name + "，年龄：" + age; &#125;&#125; 另外，this调用构造方法时一定要留一个构造方法作为出口，即程序中至少有个构造方法是不使用this调用其他构造方法的。一般都会将无参构造方法作为出口，即在无参构造方法中最好不要再去调用其他构造方法。 this表示当前对象this最重要的特点就是表示当前对象，在Java中当前对象就是指当前正在调用类中方法的对象。 1234567891011121314151617class Person04&#123; public String getInfo()&#123; System.out.println("Person类 --&gt; " + this); // 直接打印this return null; // 此处返回null，为的是让语法不出错 &#125;&#125;public class ThisDemo06 &#123; public static void main(String[] args) &#123; Person04 per1 = new Person04(); Person04 per2 = new Person04(); System.out.println("MAIN方法 --&gt; " + per1); // 直接打印对象 per1.getInfo(); System.out.println("----------------------------"); System.out.println("MAIN方法 --&gt; " + per2); // 直接打印对象 per2.getInfo(); &#125;&#125; 程序运行结果： 12345MAIN方法 --&gt; ThisDemo.Person04@21bcffb5Person类 --&gt; ThisDemo.Person04@21bcffb5----------------------------MAIN方法 --&gt; ThisDemo.Person04@380fb434Person类 --&gt; ThisDemo.Person04@380fb434 从结果来看，直接打印对象和调用getInfo()方法打印的结果是一样的，而且在getInfo()方法中打印的永远是this关键字，也就是说哪个对象调用了类中的方法，this就表示哪个对象。 这样一个特性有什么用处呢？通过下面一个例子来理解： 12]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java笔记：引用传递及基本应用]]></title>
    <url>%2F2019%2F05%2F24%2FJava%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[引用传递所谓引用传递就是指将堆内存空间的使用权交给多个栈内存空间。 引用传递范例一对象引用传递： 123456789101112131415class Demo&#123; int temp = 30; // 此处为了访问方便，属性暂时不封装&#125;public class RefDemo01 &#123; public static void main(String[] args) &#123; Demo d1 = new Demo(); d1.temp = 50; System.out.println("fun()方法调用之前：" + d1.temp); fun(d1); System.out.println("fun()方法调用之后：" + d1.temp); &#125; public static void fun(Demo d2)&#123; // 此处的方法由主方法直接调用 d2.temp = 1000; &#125;&#125; 程序运行结果： 12fun()方法调用之前：50fun()方法调用之后：1000 从结果中可以发现，在fun()方法中接收了Demo类对象d1，并将temp属性的内容进行了修改，因为是引用传递，所以最终temp的值是1000，此程序可以通过下图进行理解： 引用传递范例二引用传递： 1234567891011public class RefDemo02 &#123; public static void main(String[] args) &#123; String str1 = "hello"; // 实例化字符串对象 System.out.println("fun()方法调用之前：" + str1); fun(str1); // 调用fun()方法 System.out.println("fun()方法调用之后：" + str1); &#125; public static void fun(String str2)&#123; // 此处的方法由主方法直接调用 str2 = "MLDN"; // 修改字符串内容 &#125;&#125; 程序运行结果： 12fun()方法调用之前：hellofun()方法调用之后：hello 从运行结果可以发现，虽然此时传递的是一个String类型的对象，但是结果并没有像之前一样发生给吧，因为字符串的内容一旦声明就是不可改变的，改变的只是其内存地址的指向，如下图所示： 以上操作并不难理解，因为每个字符串对象都表示一个匿名对象，这样在fun()方法操作中，如果为str2重新设置内容，就相当于改变了str2的引用，而str1本身的内容并不会受到任何影响。 引用传递范例三123456789101112131415class Demo2&#123; String temp = "hello"; // 此处为了访问方便，属性暂不封装&#125;public class RefDemo03 &#123; public static void main(String[] args) &#123; Demo2 d1 = new Demo2(); d1.temp = "word"; // 修改对象中的temp属性 System.out.println("fun()方法调用之前：" + d1.temp); fun(d1); System.out.println("fun()方法调用之后：" + d1.temp); &#125; public static void fun(Demo2 d2)&#123; d2.temp = "MLDN"; &#125;&#125; 程序运行结果： 12fun()方法调用之前：wordfun()方法调用之后：MLDN 从结果可以看出，fun()方法中将属性的内容修改了，内存操作如下图： 本程序的分析方法与第一个范例完全一样，因为String是作为一个Demo2类的属性存在的，而在操作时更改的只是Demo2类中属性的内容。 接收本类的引用以上为引用传递的基本形式，实际上，在对象引用传递上也可以在一个类中接收自己本类对象的实例，而且接受完之后，可以方便地通过此对象直接进行本类中封装属性的访问，如下： 1234567891011121314151617181920class Demo3&#123; private int temp = 30; // 声明temp属性并封装 public void fun(Demo3 d2)&#123; // 接收本类的引用 d2.temp = 50; // 直接通过对象调用本类的私有属性 &#125; public int getTemp()&#123; // getter方法 return temp; &#125; public void setTemp(int t)&#123; // setter方法 temp = t; &#125;&#125;public class RefDemo04 &#123; public static void main(String[] args) &#123; Demo3 d1 = new Demo3(); // 实例化Demo对象 d1.setTemp(50); // 修改temp内容 d1.fun(d1); // 此处把Demo对象传回到自己的类中 System.out.println("temp = " + d1.getTemp()); &#125;&#125; 程序运行结果为：temp = 50 此种引用方式的传递在关于对象比较操作时才会经常使用，其他时候基本上都很少使用。 范例——一对一关系使用引用传递还可以表示出生活中的以下一种场景：一个人有一本书，一本书属于一个人。因而可以得出这样的结论：人应该是一个具体的类，书也应该是一个具体的类，在人的类中应该存在一个属性表示书，在书的类中也应该存在一个属性表示人。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Person&#123; private String name; // 姓名 private int age; // 年龄 private Book book; // 一个人有一本书 public Person(String name, int age)&#123; // 通过构造方法设置内容 this.setName(name); this.setAge(age); &#125; public void setName(String n)&#123; // 设置姓名 name = n; &#125; public String getName()&#123; // 返回姓名 return name; &#125; public void setAge(int a)&#123; // 设置年龄 age = a; &#125; public int getAge()&#123; // 返回年龄 return age; &#125; public void setBook(Book b)&#123; // 设置本人的书 book = b; &#125; public Book getBook()&#123; // 得到本人的书 return book; &#125;&#125;class Book&#123; private String title; // 标题 private float price; // 价格 private Person person; // 一本书属于一个人 public Book(String title, float price)&#123; // 通过构造方法设置属性内容 this.setTitle(title); this.setPrice(price); &#125; public void setTitle(String t)&#123; title = t; &#125; public String getTitle()&#123; return title; &#125; public void setPrice(float p)&#123; price = p; &#125; public float getPrice()&#123; return price; &#125; public void setPerson(Person person)&#123; this.person = person; &#125; public Person getPerson()&#123; return person; &#125;&#125;public class RefDemo05 &#123; public static void main(String[] args) &#123; Person per = new Person("张三", 30); // 实例化Person对象 Book bk = new Book("JAVA SE 核心开发", 90.0f); // 实例化Book对象 per.setBook(bk); // 设置两个对象间的关系，一个人有一本书 bk.setPerson(per); // 设置两个对象间的关系，一本书属于一个人 System.out.println("从人找到书 --&gt; 姓名：" + per.getName() + "；年龄：" + per.getAge() + "；书名：" + per.getBook().getTitle() + "；价格：" + per.getBook().getPrice()); System.out.println("从书找到人 --&gt; 书名：" + bk.getTitle() + "；价格：" + bk.getPrice() + "；姓名：" + bk.getPerson().getName() + "；年龄：" + bk.getPerson().getAge()); &#125;&#125; 程序运行结果： 12从人找到书 --&gt; 姓名：张三；年龄：30；书名：JAVA SE 核心开发；价格：90.0从书找到人 --&gt; 书名：JAVA SE 核心开发；价格：90.0；姓名：张三；年龄：30 范例——进一步深入一对一关系现在有一个新的要求，一个人有一个孩子，每个孩子还会有一本书。因为一个孩子也是一个人，所以并不需要单独建立一个孩子类，只需要简单的修改Person类，在类中增加一个自己的引用即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283class Person1&#123; private String name; // 姓名 private int age; // 年龄 private Book1 book; // 一个人有一本书 private Person1 child; // 一个人有一个孩子 public Person1(String name, int age)&#123; // 通过构造方法设置内容 this.setName(name); this.setAge(age); &#125; public void setName(String n)&#123; // 设置姓名 name = n; &#125; public String getName()&#123; // 返回姓名 return name; &#125; public void setAge(int a)&#123; // 设置年龄 age = a; &#125; public int getAge()&#123; // 返回年龄 return age; &#125; public void setBook(Book1 b)&#123; // 设置本人的书 book = b; &#125; public Book1 getBook()&#123; // 得到本人的书 return book; &#125; public void setChild(Person1 child)&#123; // 设置孩子 this.child = child; &#125; public Person1 getChild()&#123; // 得到孩子 return child; &#125;&#125;class Book1&#123; private String title; // 标题 private float price; // 价格 private Person1 person; // 一本书属于一个人 public Book1(String title, float price)&#123; // 通过构造方法设置属性内容 this.setTitle(title); this.setPrice(price); &#125; public void setTitle(String t)&#123; title = t; &#125; public String getTitle()&#123; return title; &#125; public void setPrice(float p)&#123; price = p; &#125; public float getPrice()&#123; return price; &#125; public void setPerson(Person1 person)&#123; this.person = person; &#125; public Person1 getPerson()&#123; return person; &#125;&#125;public class RefDemo06 &#123; public static void main(String[] args) &#123; Person1 per = new Person1("张三", 30); // 实例化Person对象 Person1 cld = new Person1("张草", 10); // 定义一个孩子 Book1 bk = new Book1("JAVA SE 核心开发", 90.0f); // 实例化Book对象 Book1 b = new Book1("一千零一夜", 30.3f); // 定义孩子的书 per.setBook(bk); // 设置对象间的关系，一个人有一本书 bk.setPerson(per); // 设置对象间的关系，一本书属于一个人 cld.setBook(b); // 设置对象间的关系，一个孩子有一本书 b.setPerson(cld); // 设置对象间的关系，一本书属于一个孩子 per.setChild(cld); // 设置对象间的关系，一个人有一个孩子 System.out.println("从人找到书 --&gt; 姓名：" + per.getName() + "；年龄：" + per.getAge() + "；书名：" + per.getBook().getTitle() + "；价格：" + per.getBook().getPrice()); System.out.println("从书找到人 --&gt; 书名：" + bk.getTitle() + "；价格：" + bk.getPrice() + "；姓名：" + bk.getPerson().getName() + "；年龄：" + bk.getPerson().getAge()); System.out.println(per.getName() + "的孩子 --&gt; 姓名：" + per.getChild().getName() + "；年龄：" + per.getChild().getAge() + "；书名：" + per.getChild().getBook().getTitle() + "；价格：" + per.getChild().getBook().getPrice()); &#125;&#125; 程序运行结果： 123从人找到书 --&gt; 姓名：张三；年龄：30；书名：JAVA SE 核心开发；价格：90.0从书找到人 --&gt; 书名：JAVA SE 核心开发；价格：90.0；姓名：张三；年龄：30张三的孩子 --&gt; 姓名：张草；年龄：10；书名：一千零一夜；价格：30.3]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java笔记：String]]></title>
    <url>%2F2019%2F05%2F16%2FJava%E7%AC%94%E8%AE%B0%EF%BC%9AString%2F</url>
    <content type="text"><![CDATA[String类定义时单词的首字母大写，所以String本身也是一个类本类，但是此类在使用时却有很多的要求，而且此类在Java中也算是一个比较特殊的类。 实例化String对象对于String可以采用直接赋值的方式进行操作，如下面的代码： 123456public class StringDemo01 &#123; public static void main(String[] args) &#123; String name = "LiXingHua"; // 实例化String对象 System.out.println("姓名：" + name); // 输出字符串的内容 &#125;&#125; 在String的使用上还有另外一种形式的实例化方法，就是直接调用String类中的构造方法，在String类存在以下的构造方法： 1public String(String original) 所以上面的代码也可以通过如下的代码进行编写： 123456public class StringDemo02 &#123; public static void main(String[] args) &#123; String name = new String("LiXingHua"); // 实例化String对象 System.out.println("姓名：" + name); // 输出字符串的内容 &#125;&#125; String的内容比较对于基本数据类型，可以通过“==”进行内容的比较，如下面的代码： 1234567public class StringDemo03 &#123; public static void main(String[] args) &#123; int x = 30; // 声明一个整型变量 int y = 30; // 声明一个整型变量 System.out.println("两个数字的比较结果：" + (x == y)); &#125;&#125; 程序运行结果：两个数字的比较结果：true 下面按照以上的程序思路进行两个字符串的比较操作： 12345678910public class StringDemo04 &#123; public static void main(String[] args) &#123; String str1 = "hello"; // 直接赋值 String str2 = new String("hello"); // 通过new赋值 String str3 = str2; // 传递引用 System.out.println("str1 == str2 --&gt;" + (str1 == str2)); System.out.println("str1 == str3 --&gt;" + (str1 == str3)); System.out.println("str2 == str3 --&gt;" + (str2 == str3)); &#125;&#125; 程序运行结果为： 123str1 == str2 --&gt;falsestr1 == str3 --&gt;falsestr2 == str3 --&gt;true 从程序运行结果中可以发现，虽然以上程序中String的内容都一样，但是比较结果有的相同，有的却不同。主要原因在于堆内存和栈内存。上面每个String对象的内容实际上都保存在堆内存中，而且堆内存中的内容相等。但是对于str1和str2来说，其内容分别保存在了不同的空间，所以即使内容相等，地址的值也是不相等的，“==”是用来进行数值比较的，所以str1和str2不相等。从程序中可以发现str2和str3指向了同一个堆内存空间，是同一个地址，所以最终结果是str2和str3的地址值相等的，同理str1和str3的地址值是不相等的，所以返回了false。栈内存和堆内存的示意图如下： 那么既然无法使用“==”进行判断，那该如何去判断两个字符串的内容是否相等呢？此时，即可利用String中专门提供的方法（String是一个类，则会存在各种方法）： 1public boolean equals(String str) 例如，使用equals方法对String的内容进行比较： 12345678910public class StringDemo05 &#123; public static void main(String[] args) &#123; String str1 = "hello"; // 直接赋值 String str2 = new String("hello"); // 通过new赋值 String str3 = str2; // 传递引用 System.out.println("str1 equals str2 --&gt;" + (str1.equals(str2))); System.out.println("str1 equals str3 --&gt;" + (str1.equals(str3))); System.out.println("str2 equals str2 --&gt;" + (str2.equals(str3))); &#125;&#125; 程序运行结果： 123str1 equals str2 --&gt;truestr1 equals str3 --&gt;truestr2 equals str2 --&gt;true 因为equals()方法的作用是将内容进行比较，所以此处返回的结果都为true。 String两种实例化方式的区别String又两种实例化方式，一种是通过直接赋值的方式，另一种是使用标准的new调用构造方式完成实例化。一个字符串就是一个String类的匿名对象，匿名对象就是已经开辟了堆内存空间的并可以直接使用的对象。 验证一个字符串就是String的匿名对象： 12345public class StringDemo06 &#123; public static void main(String[] args) &#123; System.out.println("\"hello\" equals \"hello\" --&gt;" + ("hello".equals("hello"))); &#125;&#125; 程序运行结果：&quot;hello&quot; equals &quot;hello&quot; --&gt;true 从结果可以发现，一个字符串确实可以调用String类中的方法，也就证明了一个字符串就是一个String类的匿名对象。所以对于以下代码： 1String str1 = "hello"; 实际上就是把一个堆中开辟好的内存空间的使用权给了str1对象，而使用这种方式还有另一个好处，就是如果一个字符串已经被一个名称所引用，则以后再有相同的字符串声明时，就不会重新开辟空间，而是继续使用已经开辟好的堆内存。例如： 1234567891011public class StringDemo07 &#123; public static void main(String[] args) &#123; // 声明3个字符串变量，每个变量的内容都是一样的 String str1 = "hello"; String str2 = "hello"; String str3 = "hello"; System.out.println("str1 == str2 --&gt;" + (str1 == str2)); System.out.println("str1 == str3 --&gt;" + (str1 == str3)); System.out.println("str2 == str3 --&gt;" + (str2 == str3)); &#125;&#125; 程序运行结果： 123str1 == str2 --&gt;truestr1 == str3 --&gt;truestr2 == str3 --&gt;true 三种比较都是true，说明3个字符串指向的堆内存地址空间都是同一个，所以，当String使用直接赋值的方式之后，只要是声明的字符串内容相同，则都不会再开辟新的内存空间。 在Java中会提供一个字符串池来保存全部的内容 对于String的以上操作，在Java中称为共享设计，这种设计思路是，在Java中形成一个对象池，在这个对象池中保存多个对象，新实例化的对象如果已经在池中定义了，则不再重新定义，而是从池中直接取出继续使用。String就是因为采用了这样的设计，所以当内容重复时，会将对象指向已存在的实例空间。 下面为使用new String()的方式实例化String对象的例子： 12345public class StringDemo08&#123; public static void main(String[] args)&#123; String str = new String("hello"); &#125;&#125; 一个字符串就是一个String类的匿名对象，而如果使用new关键字，不管如何都会再开辟一个新的空间，但是此时，此空间的内容还是hello，所以上面的代码实际上是开辟了两个内存空间，但真正使用的只是一个使用关键字new开辟的空间，另外一个就是垃圾空间了，如图： 通过以上两种实现方式比较可以知道那种方式更合适，对于字符串的操作就采用直接赋值的方式完成，而不要采用构造方法传递字符串的方式完成，这样可以避免产生垃圾空间，当然，在String类中也存在一些其他的构造方法。 字符串的内容不可改变在使用String类进行操作时还有一个特性是特别重要的，那就是字符串的内容一旦声明则不可以改变。例如： 1234567public class StringDemo09 &#123; public static void main(String[] args) &#123; String str = "hello"; // 声明字符串 str = str + " world!"; // 修改字符串 System.out.println("str = " + str); &#125;&#125; 程序运行结果：str = hello world!。 从结果来看，String对象的内容确实已经修改了，但是其实String对象内容的改变是通过内存地址的“断开-连接”变化完成的，而本身字符串中的内容并没有任何变化，具体如下图： String类中常用的方法字符串与字符数组的转换字符串可以使用toCharArray()方法变成一个字符数组，也可以使用String类的构造方法把一个字符数组变成一个字符串。 1234567891011121314public class StringAPIDemo01 &#123; public static void main(String[] args) &#123; String str1 = "hello"; // 定义字符串 char c[] = str1.toCharArray(); // 将字符串变为字符数组 for (int i = 0; i &lt; c.length; i++)&#123; // 循环输出 System.out.print(c[i] + "\t"); &#125; System.out.println(""); String str2 = new String(c); // 将全部字符数组变为String String str3 = new String(c, 0, 3); // 将部分字符数组变为String System.out.println(str2); // 输出字符串 System.out.println(str3); // 输出字符串 &#125;&#125; 程序运行结果： 123h e l l o hellohel 程序一开始将一个字符串变成一个字符数组，字符串的长度就是转换之后字符数组的长度，也可以把一个字符数组的全部或者部分转换为字符串。 从字符串中取出指定位置的字符可以使用String类中的charAt()方法去除字符串指定位置的字符。 123456public class StringAPIDemo02 &#123; public static void main(String[] args) &#123; String str1 = "hello"; // 声明String对象 System.out.println(str1.charAt(3)); // 取出字符串中的第4个字符 &#125;&#125; 程序最终取出的字符为“l”，因为字符从0开始编号，编号为3的字符为“l”。 字符串与byte数组的转换字符串可以通过getBytes()方法将String变为一个byte数组，然后可以通过String的构造方法将一个字节数组重新变为字符串。 12345678public class StringAPIDemo03 &#123; public static void main(String[] args) &#123; String str1 = "hello"; byte b[] = str1.getBytes(); // 将字符串变为byte数组 System.out.println(new String(b)); // 将全部byte数组变为字符串 System.out.println(new String(b, 1, 3)); // 将部分byte数组变为字符串 &#125;&#125; 程序运行结果： 12helloell 取得一个字符串的长度在String中使用length()方法取得字符串的长度。 123456public class StringAPIDemo04 &#123; public static void main(String[] args) &#123; String str1 = "hello LiXingHua"; // 定义字符串变量 System.out.println("\"" + str1 + "\" 的长度为：" + str1.length()); &#125;&#125; 程序运行结果：&quot;hello LiXingHua&quot; 的长度为：15。 length和length()的区别 在数组操作中，使用length取得数组的长度，但是操作的最后没有“()”，而字符串调用length是一个方法，只要是方法后面都有“()”。 查找一个指定的字符串是否存在在String中使用indexOf()方法，可以返回指定的字符串的位置，如果不存在则返回-1，例如： 12345678public class StringAPIDemo05 &#123; public static void main(String[] args) &#123; String str1 = "abcdefgcgh"; System.out.println(str1.indexOf("c")); // 查到返回位置 System.out.println(str1.indexOf("c", 3)); // 查到返回位置，从第4个开始查找 System.out.println(str1.indexOf("x")); // 没有查到返回-1 &#125;&#125; 程序运行结果： 12327-1 去掉左右空格使用trim()方法可以去掉字符串左、右空格，例如： 123456public class StringAPIDemo06 &#123; public static void main(String[] args) &#123; String str1 = " hello "; System.out.println(str1.trim()); // 去掉左右空格后输出 &#125;&#125; 程序运行结果为：hello 从程序运行的结果来看，字符串左右两边的空格都被清除掉了。 字符串截取在String中提供了两个substring()方法，一个是从指定位置截取到字符串结尾i，另一个是截取指定范围的内容。例如： 1234567public class StringAPIDemo07 &#123; public static void main(String[] args) &#123; String str1 = "hello world"; System.out.println(str1.substring(6)); // 从第7个位置开始截取 System.out.println(str1.substring(0, 5)); // 截取0~5个位置的内容 &#125;&#125; 程序运行结果： 12worldhello 需要注意的是，当截取指定范围的字符串时，截取的内容包括空号中前一个数字指定的位置，不包括括号中后一个数字指定的位置。 按照指定的字符串拆分字符串在String中通过split()方法可以进行字符串的拆分操作，拆分的数据将以字符串数组的形式返回。例如： 123456789public class StringAPIDemo08 &#123; public static void main(String[] args) &#123; String str1 = "hello world"; String s[] = str1.split(" "); // 按空格进行字符串的拆分 for (int i = 0; i &lt; s.length; i++)&#123; System.out.println(s[i]); &#125; &#125;&#125; 程序运行结果： 12helloworld 字符串的大小写转换在用户输入信息时，有时需要统一输入数据的大小写，此时就可以使用toUpperCase()和toLowerCase()两个方法完成字符串大小写的转换操作。 123456public class StringAPIDemo09 &#123; public static void main(String[] args) &#123; System.out.println("将\"hello world\"转换成大写：" + "hello world".toUpperCase()); System.out.println("将\"HELLO WORLD\"转换成小写：" + "HELLO WORLD".toLowerCase()); &#125;&#125; 程序运行结果： 12将&quot;hello world&quot;转换成大写：HELLO WORLD将&quot;HELLO WORLD&quot;转换成小写：hello world 判断是否以指定的字符串开头或结尾在String中使用startsWith()方法可以判断字符串是否以指定的内容开头，使用endsWith()方法可以判断字符串是否以指定的内容结尾。 123456789101112public class StringAPIDemo10 &#123; public static void main(String[] args) &#123; String str1 = "**HELLO"; String str2 = "HELLO**"; if (str1.startsWith("**"))&#123; System.out.println("(**HELLO)以 ** 开头"); &#125; if (str2.endsWith("**"))&#123; System.out.println("(HELLO**)以 ** 结尾"); &#125; &#125;&#125; 程序运行结果： 12(**HELLO)以 ** 开头(HELLO**)以 ** 结尾 不区分大小写进行字符串笔记在String中可以通过equals()方法进行字符串内容的比较，但是这种比较方法是区分大小写的比较，如果要完成不区分大小写的比较则可以使用equalsIgnoreCase()方法。 12345678public class StringAPIDemo11 &#123; public static void main(String[] args) &#123; String str1 = "HELLO"; String str2 = "hello"; System.out.println("\"HELLO\" equals \"hello\": " + str1.equals(str2)); // 区分大小写比较 System.out.println("\"HELLO\" equalsIngoreCase \"hello\": " + str2.equalsIgnoreCase(str2)); // 区分大小写比较 &#125;&#125; 程序运行结果： 12&quot;HELLO&quot; equals &quot;hello&quot;: false&quot;HELLO&quot; equalsIngoreCase &quot;hello&quot;: true 将一个指定的字符串替换成其他的字符串使用String的replaceAll()方法可以将字符串的指定内容进行替换。 1234567public class StringAPIDemo12 &#123; public static void main(String[] args) &#123; String str = "hello"; String newStr = str.replaceAll("l", "x"); // 将所有的l替换成x System.out.println("替换之后的结果：" + newStr); &#125;&#125; 程序运行结果为：替换之后的结果：hexxo]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java实例讲解：类设计分析]]></title>
    <url>%2F2019%2F05%2F15%2FJava%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3%EF%BC%9A%E7%B1%BB%E8%AE%BE%E8%AE%A1%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[题目定义并测试一个名为Student的类，包括的属性有“学号”、“姓名”以及3门课程“数学”、“英语”和“计算机”的成绩，包括的方法有计算3门课程的“总分”、“平均分”、“最高分”以及“最低分”。 属性及类型 序号 属性 属性类型 属性名称 1 学号 String stuno 2 姓名 String name 3 数学成绩 float math 4 英语成绩 float english 5 计算机成绩 float computer 需要的方法 序号 方法名称 返回值类型 作用 1 public void setStuno(String s) void 设置学生编号 2 public void setName(String n) void 设置学生姓名 3 public void setMath(float m) void 设置数学成绩 4 public void setEnglish(float e) void 设置英语成绩 5 public void setComputer(float c) void 设置计算机成绩 6 public String getStuno() String 取得学生编号 7 public String getName() String 取得学生姓名 8 public float getMath() float 取得数学成绩 9 public float getEnglish() float 取得英语成绩 10 public float getComputer() float 取得计算机成绩 11 public float sum() float 计算成绩总和 12 public float avg() float 计算平均成绩 13 public float max() float 求出最高成绩 14 public float min() float 求出最低成绩 151 public Student() - 无参构造方法 16 public Student(String stuno, String name, float math, float english, float computer) - 在对象实例化时直接将学号、姓名、数学成绩、英语成绩、计算机成绩设置进去 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Student&#123; private String stuno; // 学生编号 private String name; // 学生姓名 private float math; // 数学成绩 private float english; // 英语成绩 private float computer; // 计算机成绩 public Student()&#123; // 定义无参构造 &#125; // 定义有五个参数的构造方法，为类中的属性初始化 public Student(String stuno, String name, float math, float english, float computer)&#123; this.setStuno(stuno); this.setName(name); this.setMath(math); this.setEnglish(english); this.setComputer(computer); &#125; public void setStuno(String s)&#123; // 设置编号 stuno = s; &#125; public void setName(String n)&#123; // 设置姓名 name = n; &#125; public void setMath(float m)&#123; // 设置数学成绩 math = m; &#125; public void setEnglish(float e)&#123; // 设置英语成绩 english = e; &#125; public void setComputer(float c)&#123; // 设置计算机成绩 computer = c; &#125; public String getStuno()&#123; // 取得编号 return stuno; &#125; public String getName()&#123; // 取得姓名 return name; &#125; public float getMath()&#123; // 取得数学成绩 return math; &#125; public float getEnglish()&#123; // 取得英语成绩 return english; &#125; public float getComputer()&#123; // 取得计算机成绩 return computer; &#125; public float sum()&#123; return math + english + computer; // 计算总分 &#125; public float avg()&#123; // 计算平均分 return this.sum() / 3; &#125; public float max()&#123; // 最高成绩 float max = math; max = max &gt; computer ? max : computer; // 使用三目运算符 max = max &gt; english ? max : english; // 使用三目运算符 return max; &#125; public float min()&#123; // 最低成绩 float min = math; min = math &lt; computer ? math : computer; // 使用三目运算符 min = math &lt; english ? math : english; // 使用三目运算符 return min; &#125;&#125;public class ExampleDemo01 &#123; public static void main(String[] args) &#123; Student stu = null; // 声明对象 // 实例化Student对象，并通过构造方法赋值 stu = new Student("MLDN-33", "李兴华", 95.0f, 89.0f, 96.0f); System.out.println("学生编号：" + stu.getStuno()); System.out.println("学生姓名：" + stu.getName()); System.out.println("数学成绩：" + stu.getMath()); System.out.println("英语成绩：" + stu.getEnglish()); System.out.println("计算机成绩：" + stu.getComputer()); &#125;&#125; 程序运行结果： 12345学生编号：MLDN-33学生姓名：李兴华数学成绩：95.0英语成绩：89.0计算机成绩：96.0]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java实例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java笔记：匿名对象]]></title>
    <url>%2F2019%2F05%2F15%2FJava%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[匿名对象就是没有明确给出名称的对象。一般匿名对象只使用一次，而且匿名对象只在堆内存中开辟空间，而不存在栈内存的引用。 123456789101112131415161718192021222324252627282930class Person&#123; private String name; // 声明姓名属性 private int age; // 声明年龄属性 public Person(String name, int age)&#123; // 定义构造方法，为属性初始化 this.setName(name); // 为name属性赋值 this.setAge(age); // 为age属性赋值 &#125; public void tell()&#123; System.out.println("姓名：" + getName() + "，年龄：" + getAge()); &#125; public String getName()&#123; return name; &#125; public void setName(String n)&#123; name = n; &#125; public int getAge()&#123; return age; &#125; public void setAge(int a)&#123; if (a &gt;= 0 &amp;&amp; a &lt;= 150)&#123; age = a; &#125; &#125;&#125;public class NonameDemo01 &#123; public static void main(String[] args) &#123; new Person("张三", 30).tell(); // 匿名对象 &#125;&#125; 程序运行结果： 1姓名：张三，年龄：30 在以上程序的主方法中可以发现，直接使用了“new Person(“张三”, “30”)”语句，这实际上就是一个匿名对象，与之前声明的对象不同，此处没有任何栈内存引用它，所以使用一次之后就等待被垃圾收集机制回收。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java笔记：构造方法]]></title>
    <url>%2F2019%2F05%2F13%2FJava%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在面向对象程序中，构造方法的主要作用是为类中的属性初始化。在之前的学习过程中可以发现，在程序中只要出现了“()”就表示调用了方法，那么这个方法实际上就是表示要调用构造方法，构造方法可视为一种特殊的方法，它的定义方式与普通方法类似，其语法结构如下： 123456class 类名称&#123; 访问权限 类名称（类型1 参数1，类型2 参数2，···）&#123; 程序语句; ··· //构造方法没有返回值 &#125;&#125; 在构造方法的声明中，一定要注意一下几点： 构造方法的名称必须与类名称一致。 构造方法的声明处不能有任何返回值类型的声明。 不能在构造方法中使用return返回一个值。 例如，声明一个构造方法： 12345678910111213class Person&#123; public Person()&#123; // 声明构造方法 System.out.println("一个新的Person对象诞生。"); &#125;&#125;public class ConsDemo01 &#123; public static void main(String[] args) &#123; System.out.println("声明对象：Person per = null;"); Person per = null; // 声明对象时不调用构造 System.out.println("实例化对象：per = new Person();"); per = new Person(); // 实例化对象时调用构造 &#125;&#125; 程序运行结果： 123声明对象：Person per = null;实例化对象：per = new Person();一个新的Person对象诞生。 需要说明的是，只要是类就必定存在构造方法，在Java中如果一个类中没有明确的声明一个构造方法时，则在编译时会直接生成一个无参数的、什么都不做的构造方法，也就是说，如果以上的Person类中没有明确的声明构造方法，实际上编译之后的类就会为用户自动加上以下形式的构造方法： 123class Person&#123; public Person()&#123;&#125;&#125; 下面例子为通过构造方法为类中给属性赋值： 123456789101112131415161718192021222324252627282930class Person02&#123; private String name; // 声明姓名属性 private int age; // 声明年龄属性 public Person02(String name, int age)&#123; // 定义构造方法为属性初始化 this.setName(name); // 为name属性赋值 this.setAge(age); // 为age属性赋值 &#125; public void tell()&#123; // 取得信息的方法 System.out.println("姓名：" + getName() + "，年龄：" + getAge()); &#125; public String getName()&#123; // 取得姓名 return name; &#125; public void setName(String n)&#123; // 设置姓名 name = n; &#125; public int getAge()&#123; // 取得年龄 return age; &#125; public void setAge(int a)&#123; // 设置年龄 if (a &gt;= 0 &amp;&amp; a &lt;= 150)&#123; age = a; &#125; &#125;&#125;public class ConsDemo02 &#123; public static void main(String[] args) &#123; Person02 per = new Person02("张三", 30); // 调用构造方法，传递两个参数 per.tell(); &#125; 程序运行结果： 1姓名：张三，年龄：30 以上就是直接通过构造方法赋值，可以发现，这样赋值比对象实例化之后再单独调用setter方法更方便。需要说明的是，在一个类中如果已经明确地声明了一个构造方法，那么程序在编译时将不会再生成默认的构造方法，即一个类中应保证至少有一个构造方法。 与普通方法一样，构造方法也是可以重载的，只要每个构造方法的参数类型或参数个数不同，即可实现重载。例如： 1234567891011121314151617181920212223242526272829303132333435class Person03&#123; private String name; // 声明姓名属性 private int age; // 声明年龄属性 public Person03()&#123;&#125; // 定义无参构造 public Person03(String name)&#123; // 定义构造，为name属性赋值 this.setName(name); &#125; public Person03(String name, int age)&#123; // 定义构造方法为属性初始化 this.setName(name); // 为name属性赋值 this.setAge(age); // 为age属性赋值 &#125; public void tell()&#123; // 取得信息的方法 System.out.println("姓名：" + getName() + "，年龄：" + getAge()); &#125; public String getName()&#123; // 取得姓名 return name; &#125; public void setName(String n)&#123; // 设置姓名 name = n; &#125; public int getAge()&#123; // 取得年龄 return age; &#125; public void setAge(int a)&#123; // 设置年龄 if (a &gt;= 0 &amp;&amp; a &lt;= 150)&#123; age = a; &#125; &#125;&#125;public class ConsDemo03 &#123; public static void main(String[] args) &#123; Person03 per = new Person03("张三"); // 调用有一个参数的构造 per.tell(); &#125;&#125; 程序运行结果： 1姓名：张三，年龄：0 以上类的构造方法被重载了3次，在主方法中调用的是只有一个参数的构造方法（只设置姓名），因为没有设置年龄，所以年龄默认值为0。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java笔记：封装性]]></title>
    <url>%2F2019%2F04%2F18%2FJava%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%B0%81%E8%A3%85%E6%80%A7%2F</url>
    <content type="text"><![CDATA[封装性是面向对象的第一大特性，所谓的封装性就是指对外部不可见，那么为什么要有封装性呢，首先观察以下程序： 123456789101112131415class Person06&#123; String name; int age; public void tell()&#123; System.out.println("姓名：" + name + "，年龄：" + age); &#125;&#125;public class EncDemo01 &#123; public static void main(String[] args) &#123; Person06 per = new Person06(); // 声明并实例化对象 per.name = "张三"; // 为name属性赋值 per.age = -30; // 为age属性赋值 per.tell(); // 调用方法 &#125;&#125; 程序运行结果： 1姓名：张三，年龄：-30 年龄赋值为-30在程序中是正确的，因为int可以取负值，但是在实际中没有人的年龄是负的。之前所列举的程序都是用对象直接访问类中的属性，这在面向对象法则中是不允许的，所以为了避免程序中这种错误的发生，在一般的开发中往往要将类中的属性封装，封装的格式如下： 12属性封装： private 属性类型 属性名称；方法封装： private 方法返回值 方法名称（参数列表）&#123;&#125; 例如，为程序加上封装属性： 123456789101112131415class Person07&#123; private String name; // 声明姓名属性 private int age; // 声明年龄属性 public void tell()&#123; System.out.println("姓名：" + name + "，年龄：" + age); &#125;&#125;public class EncDemo02 &#123; public static void main(String[] args) &#123; Person07 per = new Person07(); per.name = "张三"; per.age = -30; per.tell(); &#125;&#125; 程序会编译出错，本程序与上面的程序除了在声明属性上有些区别外，并没有其他的区别，而就是一个小小的关键字private，使程序连编译都无法通过，而所提示的错误为“属性（name、age）为私有的”，所以不能由对象直接进行访问，这样就可以保证对象无法直接去访问类中是属性，从而保证堆入口处有所限制，可是这样以来又该如何访问此属性呢？为了解决属性必须封装且必须访问的矛盾，在Java开发中对于私有属性的访问有了以下的明确定义：“只要是被封装的属性，则必须通过setter和getter方法设置和取得”。 为前面类中的私有属性加上setter和getter方法： 123456789101112131415161718192021222324252627class Person08&#123; private String name; private int age; public void tell()&#123; System.out.println("姓名：" + getName() + "，年龄：" + getAge()); &#125; public String getName()&#123; return name; // 取得姓名 &#125; public void setName(String n)&#123; // 设置姓名 name = n; &#125; public int getAge()&#123; // 取得年龄 return age; &#125; public void setAge(int a)&#123; // 设置年龄 age = a; &#125;&#125;public class EncDemo03 &#123; public static void main(String[] args) &#123; Person08 person = new Person08(); // 声明并实例化对象 person.setName("张三"); // 调用setter设置姓名 person.setAge(-30); // 调用setter设置年龄 person.tell(); // 输出信息 &#125;&#125; 程序运行结果： 1姓名：张三，年龄：-30 观察程序的结构，可以发现通过setter和getter方法可以设置和取得属性，而在主方法调用时，也是调用了setter()方法进行内容的赋值，也就是说如果想要堆设置进去的值进行检查，则只需要在setter()方法中加入检查代码即可。 1234567891011121314151617181920212223242526272829class Person09&#123; private String name; private int age; public void tell()&#123; System.out.println("姓名：" + name + "，年龄：" + age); &#125; public String getName()&#123; return name; &#125; public void setName(String n)&#123; name = n; &#125; public int getAge()&#123; return age; &#125; public void setAge(int a)&#123; if (a&gt;=0 &amp;&amp; a&lt;150)&#123; // 在此处加上验证代码 age = a; &#125; &#125;&#125;public class EncDemo04 &#123; public static void main(String[] args) &#123; Person09 per = new Person09(); per.setName("张三"); per.setAge(-30); per.tell(); &#125;&#125; 程序运行结果： 1姓名：张三，年龄：0 因为程序中的setter方法处加入了验证代码，所以如果年龄数值不正确，则不会把值赋给age属性，所以程序的运行结果为0。 关于private的补充说明 （1）类中的属性都必须封装，封装之后的属性必须通过setter和getter进行访问。 （2）面向对象的封装性本身并不是单单指private关键字，用private声明的属性或方法只能在其类的内部被调用，而不能在类的外部被调用。 （3）正常情况下，类中的方法直接写上方法名称就可以完成本类中的方法调用，如果在此时非要枪带哦时本类中的方法，也可以在调用时按“this.方法名称()”的形式编写。 程序中的属性进行封装后，在使用类图表示封装属性时就必须按照如下的风格： 1-属性名称：数据类型 其中“-”表示private。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java笔记：类与对象]]></title>
    <url>%2F2019%2F04%2F15%2FJava%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[类与对象的关系在面向对象中，类和对象是最基本、最重要的组成单元。类实际上是表示一个客观世界某类群体的一些基本特征抽象。对象就是表示一个个具体的东西。例如，现实生活中，人可以称为一个类，因为人是一种广义的概念，并不是具体的。而某一个人就可以称为一个对象，某个人可以通过他的各种特征来描述，例如姓名、性别、年龄等。这些信息在面向对象的概念中就称为属性；当然人是可以吃饭、睡觉的，这些人的行为在类中就称为方法。 如果要使用一个类，就一定要产生一个对象，每个对象之间是靠属性的不同来进行区分的，而每个对象所具备的操作就是类中规定好的方法。 类的定义类是由属性和方法组成的，属性中定义的是类需要的一个个具体信息，实际上一个属性就是一个变量，而方法是一些操作行为，但是在程序设计中，定义类也是要按照具体的语法要求完成的，类的定义语法如下： 12345678class 类名称&#123; 数据类型 属性； ··· public 返回值的数据类型 方法名称（参数1，参数2...）&#123; 程序语句； [return 表达式；] &#125;&#125; 类中定义方法的补充说明 可以发现，此处的方法与之前的方法定义有区别，并没有加上static关键字，这是因为此时定义的方法将有对象调用，而不像之前那样与主方法定义在一个类中并且由主方法之间调用。 例如我们定义一个Person类： 1234567class Person&#123; String name; // 声明姓名属性 int age; // 声明年龄属性 public void tell()&#123; // 取得信息的方法 System.out.println("姓名：" + name + "，年龄：" + age); &#125;&#125; 类定义完成后，我们可以通过下图所示的图形样式来表示出类的定义： Person name : String age : int + tell() : void 第一层表示类的名称，类的名称要求开头首字母大写。 第二层表示属性的定义，按照“访问权限 属性名称：属性类型”的格式定义，在本类中因为声明属性处没有写任何的访问权限，所以前面暂时不加任何的符号。 第三层表示类中方法的定义，按照“访问权限 方法名称():方法返回值”的格式定义，在本类中，方法的声明处加上了public（此为访问权限，表示任何地方都可以访问），所以使用“+”表示，另外，如果方法中由传递的参数，则此方法定义格式为“访问权限 方法名称(参数名称: 参数类型, 参数名称: 参数类型, …): 方法返回值” 对象的创建及使用要想使用一个类则必须由对象，下面给出了对象的创建格式： 12类名 对象名称 = null; // 声明对象对象名称 = new 类名(); // 实例化对象 以上格式产生对象分为声明对象和实例化对象两步。 当然也可以直接通过以下方式一步完成： 1类名 对象名称 = new 类名(); 以上格式与之前数组定义的格式相似，因为类和数组都属于引用数据类型，只要引用数据类型的使用格式都可以使用如上的定义样式。 创建对象的具体范例： 123456789101112class Person&#123; String name; // 声明姓名属性 int age; // 声明年龄属性 public void tell()&#123; // 取得信息的方法 System.out.println("姓名：" + name + "，年龄：" + age); &#125;&#125;public class ClassDemo02&#123; public static void main(String args[])&#123; Person per = new Person(); // 创建并实例化对象 &#125;&#125; 如果要使用对象访问类中的某个属性或方法可以使用如下的语法实现： 12访问属性：对象名称.属性名访问方法：对象名称.方法名() 例如： 1234567891011121314151617class Person2&#123; String name; // 声明姓名属性 int age; // 声明年龄属性 public void tell()&#123; System.out.println("姓名：" + name + "，年龄：" + age); &#125;&#125;public class ClassDemo03 &#123; public static void main(String[] args) &#123; Person2 per = null; // 声明对象 per = new Person2(); // 实例化对象 per.name = "张三"; // 为name属性赋值 per.age = 30; // 为age属性赋值 per.tell(); // 调用类中的方法 &#125;&#125; 程序运行结果： 1姓名：张三，年龄：30 创建多个对象前面介绍过创建一个对象的方法，可以按照同样的格式同时创建多个对象，每个对象会分别占据自己的堆、栈空间。 创建两个对象： 1234567891011121314151617181920212223class Person3&#123; String name; // 声明姓名属性 int age; // 声明年龄属性 public void tell()&#123; System.out.println("姓名：" + name + "，年龄：" + age); &#125;&#125;public class ClassDemo04 &#123; public static void main(String[] args) &#123; Person3 per1 = null; // 声明per1对象 Person3 per2 = null; // 声明per2对象 per1 = new Person3(); // 实例化per1对象 per2 = new Person3(); // 实例化per2对象 per1.name = "张三"; // 设置per1对象的name属性内容 per1.age = 30; // 设置per1对象的age属性内容 per2.name = "李四"; // 设置per2对象的name属性内容 per2.age = 33; // 设置per2对象的age属性内容 System.out.print("per1对象中的内容 --&gt;"); per1.tell(); // per1调用方法 System.out.print("per2对象中的内容 --&gt;"); per2.tell(); // per2调用方法 &#125;&#125; 程序运行结果： 12per1对象中的内容 --&gt;姓名：张三，年龄：30per2对象中的内容 --&gt;姓名：李四，年龄：33 类属于引用数据类型，而且从数组的使用上也可以发现，引用数据类型就是指一段堆内存空间可以同时被多个栈内存指向。下面来看一个引用传递的例子： 1234567891011121314151617181920212223class Person4&#123; String name; int age; public void tell()&#123; System.out.println("姓名：" + name + "，年龄：" + age); &#125;&#125;public class ClassDemo05 &#123; public static void main(String[] args) &#123; Person4 per1 = null; Person4 per2 = null; per1 = new Person4(); per2 = per1; // 把per1的堆内存空间使用权给per2 per1.name = "张三"; per1.age = 30; // 设置per2对象的内容，实际上就是设置per1对象的内容 per2.age = 33; System.out.print("per1对象中的内容 --&gt;"); per1.tell(); System.out.print("per2对象中的内容 --&gt;"); per2.tell(); &#125;&#125; 程序运行结果： 12per1对象中的内容 --&gt;姓名：张三，年龄：33per2对象中的内容 --&gt;姓名：张三，年龄：33 从程序运行结果可以发现，两个对象的输出内容是一样的，实际上所谓的引用传递就是将一个堆内存空间的使用权给多个栈内存空间，每个栈内存空间都可以修改堆内存的内容。 123456789101112131415161718192021222324class Person5&#123; String name; int age; public void tell()&#123; System.out.println("姓名：" + name + "，年龄：" + age); &#125;&#125;public class ClassDemo06 &#123; public static void main(String[] args) &#123; Person5 per1 = null; Person5 per2 = null; per1 = new Person5(); per2 = new Person5(); per1.name = "张三"; per1.age = 30; per2.name = "李四"; per2.age = 33; per2 = per1; System.out.print("per1对象中的内容 --&gt;"); per1.tell(); System.out.print("per2对象中的内容 --&gt;"); per2.tell(); &#125;&#125; 程序运行结果为： 12per1对象中的内容 --&gt;姓名：张三，年龄：30per2对象中的内容 --&gt;姓名：张三，年龄：30 因为per2本身有堆内存空间，所以如果要想再指向per1对应的空间，则必须先断开已有的连接。而per2原来的空间没有任何的栈内存空间所引用，就形成了垃圾空间，等待垃圾收集机制进行回收。 关于垃圾空间的释放 Java本身提供垃圾收集机制（Garbage Collection, GC），会不定期地释放不用的内存空间，只要对象不使用了，就会等待GC释放空间。 从上面的程序中明确的一点，即一个栈内存空间只能指向一个堆内存空间，如果要想再指向其他的堆内存空间，则必须先断开已有的指向才能分配新的指向。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java开发实战经典习题4-6]]></title>
    <url>%2F2019%2F04%2F05%2FJava%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E7%BB%8F%E5%85%B8%E4%B9%A0%E9%A2%984-6%2F</url>
    <content type="text"><![CDATA[编写程序求1!+2!+···+30!的和并显示，要求使用方法完成。12345678910111213141516public class Test4_1 &#123; public static void main(String[] args) &#123; float sum = 0; for (int i = 1; i&lt;31; i++)&#123; sum = sum + Factorial(i); &#125; System.out.println("1!+2!+...+30! = " + sum); &#125; public static float Factorial(int x)&#123; float temp = 1; for (int i = 1; i&lt;=x; i++)&#123; temp = temp*i; &#125; return temp; &#125;&#125; 也可以利用递归的方法： 12345678910111213141516public class Test4_1 &#123; public static void main(String[] args) &#123; float sum = 0; for (int i = 1; i&lt;31; i++)&#123; sum = sum + Factorial(i); &#125; System.out.println("1!+2!+...+30! = " + sum); &#125; public static float Factorial(int x)&#123; if (x==1)&#123; return 1; &#125; else &#123; return x * Factorial(x-1); &#125; &#125;&#125; 程序运行结果为：1!+2!+...+30! = 2.7441084E32。 定义一个由整数组成的数组，要求求出其中的奇数个数和偶数个数。1234567891011121314151617181920public class Test4_2 &#123; public static void main(String[] args) &#123; int arr[] = &#123;45, 32, 66, 77, 98&#125;; oddEven(arr); &#125; public static void oddEven(int temp[])&#123; int odd = 0; int even = 0; for (int i = 0; i&lt;temp.length; i++)&#123; int n = temp[i] % 2; if (n==0)&#123; even = even + 1; &#125;else &#123; odd = odd +1; &#125; &#125; System.out.println("奇数个数为：" + odd); System.out.println("偶数个数为：" + even); &#125;&#125; 现在有如下的一个数组int oldArr[]={1,3,4,5,0,0,6,6,0,5,4,7,6,7,0,5};，要求将以上数组中值为0的项去掉，将不为0的值存入一个新的数组，生成新数组为int newArr[]={1,3,4,5,6,6,5,4,7,6,7,5}。12345678910111213141516public class Test4_3 &#123; public static void main(String[] args) &#123; int oldArr[] = &#123;1, 3, 4, 5, 0, 0, 6, 6, 0, 5, 4, 7, 6, 7, 0, 5&#125;; int newArr[]= new int[oldArr.length]; int j = 0; for (int i = 0; i&lt;oldArr.length; i++)&#123; if (oldArr[i] != 0)&#123; newArr[j] = oldArr[i]; j++; &#125; &#125; for (int i = 0; i&lt;j; i++)&#123; System.out.print(newArr[i] + "\t"); &#125; &#125;&#125; 定义一个整型数组，求出数组元素的和、数组元素的最大值和最小值，并输出所求的结果。1234567891011121314151617181920212223public class Test4_4 &#123; public static void main(String[] args) &#123; int arr[] = &#123;1, 5, 6, 3, 8&#125;; print(arr); &#125; public static void print(int temp[])&#123; int sum = 0; int max = temp[0]; int min = temp[0]; for (int i = 0; i &lt; temp.length; i++)&#123; sum = sum + temp[i]; if (max &lt; temp[i])&#123; max = temp[i]; &#125; if (min &gt; temp[i])&#123; min = temp[i]; &#125; &#125; System.out.println("数组元素之和为：" + sum); System.out.println("数组中的最大值为：" + max); System.out.println("数组中的最小值为：" + min); &#125;&#125; 给出10个整数（int型），然后任意查询一个数字是否存在再该10个数字内。12345678910111213141516171819202122public class Test4_5 &#123; public static void main(String[] args) &#123; int arr[] = &#123;2, 3, 4, 5, 6&#125;; int num1 = 3; int num2 = 7; print(num1, arr); print(num2, arr); &#125; public static void print(int x, int temp[])&#123; int count = 0; for (int i = 0; i&lt;temp.length; i++)&#123; if (x == temp[i])&#123; count++; &#125; &#125; if (count&gt;0)&#123; System.out.println(x + "在这十个数中"); &#125;else &#123; System.out.println(x + "不在这十个数中"); &#125; &#125;&#125; 定义一个包含10个元素的数组，对其进行赋值，使每个元素的值等于其下标，然后输出；最后将这个数组倒置（即首尾交换）后输出。1234567891011public class Test4_6 &#123; public static void main(String[] args) &#123; int arr[] = new int[10]; for (int i = 0; i&lt;arr.length; i++)&#123; arr[i] = i; &#125; for (int j = arr.length-1; j&gt;=0; j--)&#123; System.out.print(arr[j] + "\t"); &#125; &#125;&#125; 给出10个老师的打分，对10个老师的打分找到最高分。123456789101112public class Test4_7 &#123; public static void main(String[] args) &#123; int score[] = &#123;67, 88, 78, 69, 100, 57, 81, 89, 94, 91&#125;; int max = 0; for (int i = 0; i&lt;score.length; i++)&#123; if (max&lt;score[i])&#123; max = score[i]; &#125; &#125; System.out.println("10个老师打分中最高分为：" + max); &#125;&#125; 有30个0~9之间的数字，分别统计0~9这10个数字分别出现了多少次。123456789101112131415161718public class Test4_8 &#123; public static void main(String[] args) &#123; int arr[] = &#123;0,1,2,3,1,3,2,5,3,8,9,1,4,2,0,5,7,3,5,3,7,9,0,2,3,5,7,8,9,2&#125;; for (int i = 0; i&lt;10; i++)&#123; int num = count(i, arr); System.out.println(i + "在数组中出现的次数为：" + num); &#125; &#125; public static int count(int x, int temp[])&#123; int num = 0; for (int i = 0; i&lt;temp.length; i++)&#123; if (x==temp[i])&#123; num++; &#125; &#125; return num; &#125;&#125; 定义一个整型数组，保存10个数据，利用程序完成将最大值保存在数组中的第一个元素的操作。12345678910111213141516171819202122232425public class Test4_9 &#123; public static void main(String[] args) &#123; int arr[] = &#123;9, 45, 11, 22, 33, 44, 51, 65, 21, 200&#125;; int max = arr[0]; int num = 0; System.out.println("原数组为："); for (int i = 0; i&lt;arr.length; i++)&#123; System.out.print(arr[i] + "\t"); &#125; for (int j = 0; j&lt;arr.length; j++)&#123; if (max&lt;arr[j])&#123; max = arr[j]; num = j; &#125; &#125; int temp = arr[0]; arr[0] = max; arr[num] = temp; System.out.println(" "); System.out.println("最大值保存在数组中的第一个元素后:"); for (int i = 0; i&lt;arr.length; i++)&#123; System.out.print(arr[i] + "\t"); &#125; &#125;&#125; 在排序号的数组中添加一个数字，将添加后的数组插入到数组合适的位置。123456789101112131415161718192021222324252627282930public class Test4_10 &#123; public static void main(String[] args) &#123; int num = 10; int arr[] = &#123;2, 5, 9, 11, 13&#125;; insert(num, arr); &#125; public static void insert(int x, int arr[])&#123; int newArr[] = new int[arr.length+1]; int temp = 0; for (int i = 0; i&lt;arr.length; i++)&#123; if (x&lt;arr[i])&#123; temp = i; newArr[temp] = x; break; &#125;else &#123; temp = arr.length; //如果要插入的数字是否比数组中最后一个数字大 newArr[temp] = x; &#125; &#125; for (int j = 0; j&lt;temp; j++)&#123; newArr[j] = arr[j]; &#125; for (int j = temp+1; j&lt;newArr.length; j++)&#123; newArr[j] = arr[j-1]; &#125; for (int i = 0; i&lt;newArr.length; i++)&#123; System.out.print(newArr[i] + "\t"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java笔记：Java新特性对数组的支持]]></title>
    <url>%2F2019%2F04%2F05%2FJava%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E6%96%B0%E7%89%B9%E6%80%A7%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E6%94%AF%E6%8C%81%2F</url>
    <content type="text"><![CDATA[Java新特性——可变参数在调用一个方法时，必须根据方法的定义传递指定的参数，但是在JDK 1.5（JAVA SE 5.0）之后产生了新的概念——可变参数，即方法中可以接收的参数不再是固定的，而是随着需要传递的，可变参数的定义格式如下： 1返回值类型 方法名称(类型...参数名称)&#123;&#125; 向方法中传递可变参数后，其中的参数是以数组的形式保存下来的。 123456789101112131415public class NewDemo01 &#123; public static void main(String[] args) &#123; System.out.print("不传递参数 （fun()）："); fun(); // 不传递参数 System.out.print("\n传递1个参数 （fun(1)）："); fun(1); // 传递一个参数 System.out.print("\n传递5个参数 （fun(1, 2, 3, 4, 5)）："); fun(1, 2, 3, 4, 5); // 传递五个参数 &#125; public static void fun(int...arg)&#123; // 可变参数，可以接收任意多个参数 for (int i = 0; i&lt;arg.length; i++)&#123; System.out.print(arg[i] + "、"); &#125; &#125;&#125; 程序输出结果为： 123不传递参数 （fun()）：传递1个参数 （fun(1)）：1、传递5个参数 （fun(1, 2, 3, 4, 5)）：1、2、3、4、5、 在使用可变参数的时候，也可以直接向方法中传递一个数组，如下所示： 12int temp[] = &#123;1, 3, 5&#125;; // 定义数组fun(temp); // 向可变参数中传递数组 对于以上传递数组的操作，也可以变成以下形式的代码： 1fun(new int[] &#123;1, 3, 5&#125;) Java新特性——foreach输出数组的输出一般都会使用for循环，但是在JDK 1.5之后为了方便数组的输出，提供了一种foreach语法，此语法的使用格式如下： 123for(数据类型 变量名称：数组名称)&#123; ...&#125; 例如： 123456789101112131415public class NewDemo02 &#123; public static void main(String[] args) &#123; System.out.print("不传递参数 （fun()）："); fun(); // 不传递参数 System.out.print("\n传递1个参数 （fun(1)）:"); fun(1); // 传递一个参数 System.out.print("\n传递5个参数 （fun(1, 2, 3, 4, 5)）："); fun(1, 2, 3, 4, 5); // 传递五个参数 &#125; public static void fun(int...arg)&#123; // 可变参数，可以接收任意多个参数 for (int x : arg)&#123; // 使用foreach输出 System.out.print(x + "、"); &#125; &#125;&#125; 程序运行结果为： 123不传递参数 （fun()）：传递1个参数 （fun(1)）:1、传递5个参数 （fun(1, 2, 3, 4, 5)）：1、2、3、4、5、]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java笔记：数组的引用传递]]></title>
    <url>%2F2019%2F04%2F05%2FJava%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E7%BB%84%E7%9A%84%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[传递及返回数组前面的方法操作中，传递和返回的都是基本数据类型，除此之外，方法中也可以传递和返回数组。如果要向方法中传递一个数组，则方法的接收参数必须是符合其类型的数组。而且数组属于引用数据类型，所以在把数组传递进方法之后，如果方法对数组本身做了任何修改，修改结果也将保存下来。 向方法中传递数组： 123456789101112public class ArrayDefDemo01 &#123; public static void main(String[] args) &#123; int temp[] = &#123;1, 3, 5&#125;; // 使用静态初始化定义数组 fun(temp); // 传递数组引用 for (int i = 0; i &lt; temp.length; i++)&#123; // 循环输出 System.out.print(temp[i] + "、"); &#125; &#125; public static void fun(int x[])&#123; // 接收整型数组引用 x[0] = 6; //修改第1个元素的内容 &#125;&#125; 程序运行结果为：6、3、5、 在程序中将第一个整型数组temp传递到了方法中，然后在fun()方法中将此整型数组的第一个元素的内容修改为6，因为数组是引用数据类型，所以，即使方法本身没有任何的返回值，修改后的结果也会被保存下来。一开始声明的temp数组的内容是“1、3、5”，但是将此数组传递到了方法中，并使用数组x接收，也就是说此时temp实际上是将堆内存空间的使用权传递给了方法，为数组的具体内容起了一个别名x，然后在方法中通过x修改数组中的内容，方法执行完毕之后，数组x因为是局部变量所以就失效了，但是对于数组内容的改变却保留了下来，也就是数组引用传递的过程。 既然方法可以接收一个数组，那么方法也可以返回一个数组，只需要返回值类型声明处明确地写出返回的数据类型即可。例如： 123456789101112131415public class ArrayRefDemo02 &#123; public static void main(String[] args) &#123; int temp[] = fun(); // 通过方法实例化数组 print(temp); // 向print()方法中传递数组 &#125; public static void print(int x[])&#123; // 接收数组 for (int i = 0; i &lt; x.length; i++)&#123; // 循环输出 System.out.print(x[i] + "、"); &#125; &#125; public static int[] fun()&#123; int ss[] = &#123;1, 3, 5, 7, 9&#125;; // 定义一个数组 return ss; // 返回数组 &#125;&#125; 程序运行结果：1、3、5、7、9、。 范例——数组排序将数组排序程序修改成一个方法的调用形式： 123456789101112131415161718192021222324252627public class ArrayDefDemo03 &#123; public static void main(String[] args) &#123; int score[] = &#123;67, 89, 87, 69, 90, 100, 75, 90&#125;; int age[] = &#123;31, 30, 18, 17, 8, 9, 1, 39&#125;; sort(score); // 数组排序 print(score); // 数组打印 System.out.println("\n----------------------------------------"); sort(age); // 数组排序 print(age); // 数组打印 &#125; public static void sort(int temp[])&#123; for (int i = 1; i &lt; temp.length; i++)&#123; // 使用冒泡排序算法 for (int j = 0; j &lt; temp.length; j++)&#123; if (temp[i]&lt;temp[j])&#123; int x = temp[i]; temp[i] = temp[j]; temp[j] = x; &#125; &#125; &#125; &#125; public static void print(int x[])&#123; for (int i = 0; i&lt;x.length; i++)&#123; System.out.print(x[i] + "\t"); &#125; &#125;&#125; 程序运行结果为： 12367 69 75 87 89 90 90 100 ----------------------------------------1 8 9 17 18 30 31 39 以上程序分别把排序和输出的功能定义为方法，然后直接调用这两个方法进行数组的排序和输出。 当然，对于排序操作，Java本身也是有类库支持的，我们可以直接使用“java.util.Arrays.sort(数组名称)”对数组进行排序，例如： 12345678910111213141516public class ArrayDefDemo04 &#123; public static void main(String[] args) &#123; int score[] = &#123;67, 89, 87, 69, 90, 100, 75, 90&#125;; int age[] = &#123;31, 30, 18, 17, 8, 9, 1, 39&#125;; java.util.Arrays.sort(score); // 使用Java提供的排序操作 print(score); // 输出数组 System.out.println("\n-------------------------------"); java.util.Arrays.sort(age); print(age); &#125; public static void print(int x[])&#123; for (int i = 0; i&lt;x.length; i++)&#123; System.out.print(x[i] + "\t"); &#125; &#125;&#125; 程序运行结果为： 12367 69 75 87 89 90 90 100 -------------------------------1 8 9 17 18 30 31 39 范例——数组复制如果给定两个数组，将其中一个数组指定位置的内容复制给另外一个数组，可以是使用方法来完成，在方法中接收5个参数，分别为“源数组名称”、“源数组开始点”、“目标数组名称”、“目标数组开始点”、“复制长度”。具体操作如下： 12345678910111213141516171819public class ArrayCopyDemo01 &#123; public static void main(String[] args) &#123; int i1[] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; // 源数组 int i2[] = &#123;11, 22, 33, 44, 55, 66, 77, 88, 99&#125;; // 目标数组 copy(i1, 3, i2, 1, 3); // 调用复制方法 print(i2); // 输出数组 &#125; // 参数含义：源数组名称、源数组开始点、目标数组名称、目标数组开始点、复制长度 public static void copy(int s[], int s1, int o[], int s2, int len)&#123; for (int i = 0; i &lt; len; i++)&#123; o[s2+i] = s[s1+i]; // 修改目标数组内容 &#125; &#125; public static void print(int x[])&#123; for (int i = 0; i&lt;x.length; i++)&#123; System.out.print(x[i] + "\t"); &#125; &#125;&#125; 程序运行结果为：11 4 5 6 55 66 77 88 99。 同样的，在Java中也存在复制的类库支持，直接使用System.arraycopy()方法即可，此方法中也要接收参数，参数的接收顺序及意义与上面的范例中的copy()方法相同。例如： 12345678910111213public class ArrayCopyDemo02 &#123; public static void main(String[] args) &#123; int i1[] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; int i2[] = &#123;11, 22, 33, 44, 55, 66, 77, 88, 99&#125;; System.arraycopy(i1, 3, i2, 1,3); print(i2); &#125; public static void print(int x[])&#123; for (int i = 0; i&lt;x.length; i++)&#123; System.out.print(x[i] + "\t"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java笔记：方法的声明及使用]]></title>
    <url>%2F2019%2F04%2F04%2FJava%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%96%B9%E6%B3%95%E7%9A%84%E5%A3%B0%E6%98%8E%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[方法的定义方法就是一段可重复调用的代码，在有些地方也把方法叫做函数。方法的定义在Java中可以使用多种方式，以下格式定义的方法可以直接使用主方法（main()）调用，是因为在方法声明处加上了public static关键字。方法暂时使用如下的语句进行定义： 1234public station 返回值类型 方法名称（类型 参数1，类型 参数2，···）&#123; 程序语句； [return 表达式]；&#125; 要特别注意的是，如果不需要传递参数到方法中，只要将括号写出，不必填入任何类容。此外，如果方法没有返回值，则在返回类型处要明确写出void，此时，在方法中的return语句可以省略，方法执行完成之后无论是否存在返回值都将返回到方法的调用处并向下继续执行。 例如，定义一个方法，在主方法中调用： 12345678910111213141516public class MethodDemo01 &#123; public static void main(String[] args) &#123; printInfo(); // 调用printInfo方法 printInfo(); // 调用printInfo方法 printInfo(); // 调用printInfo方法 System.out.println("Hello World!"); &#125; // 此处由于此方法是由main()方法直接调用的，所以一定要加上public static public static void printInfo()&#123; // 此处方法没有返回值 char c[] = &#123;'H', 'e', 'l', 'l', 'o', ',', 'L', 'X', 'H'&#125;; for (int i =0; i &lt; c.length; i++)&#123; System.out.print(c[i]); // 循环输出 &#125; System.out.println(""); // 换行 &#125;&#125; 程序运行结果： 1234Hello,LXHHello,LXHHello,LXHHello World! 从程序中可以发现，因为printInfo()方法本身不需要任何的返回值声明，所以使用了void关键字进行了声明，表示此方法不需要任何的返回值，所以不需要编写return语句。 方法命名规范要求 在定义类时，全部单词的首字母必须大写，那么在定义方法时也有命名规范要求，即第一个单词的首字母小写，之后每一个单词的首字母大写，如printInfo()方法。 前面介绍了没有返回值的方法，下面是有返回值的方法例子： 1234567891011121314151617181920public class MethodDemo02 &#123; public static void main(String[] args) &#123; int one = addOne(10, 20); // 调用整数的加法操作 float two = addTwo(10.3f, 13.3f); // 调用浮点数的加法操作 System.out.println("addOne的计算结果：" + one); System.out.println("addTwo的计算结果：" + two); &#125; // 定义方法，完成两个整数的加法操作，方法返回一个int型数据 public static int addOne(int x, int y)&#123; int temp = 0; // temp为局部变量，只在此方法中有效 temp = x + y; // 执行加法计算 return temp; // 返回计算结果 &#125; // 定义方法，完成两个浮点数的加法操作，方法返回一个float型数据 public static float addTwo(float x, float y)&#123; float temp = 0; // temp为局部变量，只在此方法中有效 temp = x + y; // 执行加法计算 return temp; // 返回计算结果 &#125;&#125; 程序运行结果： 12addOne的计算结果：30addTwo的计算结果：23.6 另外，在方法中可以定义多个变量，这些变量只在方法的内部起作用，所以也可以把这些变量称为局部变量。 方法的重载在面的addOne()和addTwo()两种方法的演示中，我们可以发现，两种方法都是做加法运算，其本质是相同的，应该统一为add()方法才对，为了解决这个问题，Java中引入了方法重载的概念。所谓的方法重载就是方法名称相同，但是参数的类型和参数的个数不同。通过传递参数的个数及类型的不同可以完成不同功能方法的调用。 验证方法的重载： 12345678910111213141516171819202122232425public class MethodDemo03 &#123; public static void main(String[] args) &#123; int one = add(10, 20); // 调用有两个参数的整型加法 int two = add(10, 20, 30); // 调用有三个参数的整型加法 float three = add(10.3f, 13.3f); // 调用有两个参数的浮点型加法 System.out.println("add(int x, int y)的计算结果：" + one); System.out.println("add(int x, int y, int z)的计算结果：" + two); System.out.println("add(float x, float y)的计算结果：" + three); &#125; public static int add(int x, int y)&#123; int temp = 0; temp = x + y; return temp; &#125; public static int add(int x, int y, int z)&#123; int temp = 0; temp = x + y + z; return temp; &#125; public static float add(float x, float y)&#123; float temp = 0; temp = x + y; return temp; &#125;&#125; 程序运行结果： 123add(int x, int y)的计算结果：30add(int x, int y, int z)的计算结果：60add(float x, float y)的计算结果：23.6 从程序中可以发现，add()方法被重载了3次，而且每次重载时的参数类型或个数都有不同，所以在调用时，会根据参数的类型和个数自动进行区分。 另外，需要注意的是，方法的重载一定只是在参数上的类型或个数有所不同，下面的代码不是方法重载的运用： 12345678910public static float add(int x, int y)&#123; // 返回floa型，但参数类型及个数一致 float temp = 0; temp = x + y; return temp;&#125;public static int add(int x, int y)&#123; // 返回int型，但参数类型及个数一致 int temp = 0; temp = x + y; return temp;&#125; 上面的两个方法的接收参数类型和个数完全一样，但只是方法的返回值类型不同，上面的代码程序也是不可能通过编译通过的，所以不是方法重载。 使用return结束一个方法在Java的方法定义中，可以使用return语句直接结束一个方法的执行，如下所示： 1234567891011121314public class MethodDemo04 &#123; public static void main(String[] args) &#123; System.out.println("1、调用fun()方法之前。"); fun(10); System.out.println("2、调用fun()方法之后。"); &#125; public static void fun(int x)&#123; System.out.println("3、进入fun()方法。"); if (x==10)&#123; return; // 结束方法，返回被调用处 &#125; System.out.println("4、正常执行完fun()方法。"); &#125;&#125; 程序运行结果： 1231、调用fun()方法之前。3、进入fun()方法。2、调用fun()方法之后。 从结果可以看出，虽然return中没有返回任何内容，但是一旦执行到了return语句之后，方法将不再执行，而返回到被调用处继续向下执行。 方法的递归调用递归调用是一种特殊的调用形式，属于方法自身调用，如下图： 例如，要完成一个数字的累加操作，除了可以使用循环方式外，还可以使用递归调用： 12345678910111213public class MethodDemo05 &#123; public static void main(String[] args) &#123; System.out.println("计算结果：" + sum(100)); // 调用操作 &#125; public static int sum(int num)&#123; if (num == 1)&#123; return 1; &#125; else &#123; return num + sum(num - 1); // 递归调用 &#125; &#125;&#125; 程序运行结果为：计算结果：5050 值得注意的是，递归调用时必须有一个明确的结束条件，然后不断改变传入的数据，才能实现递归调用。 递归调用在操作时如果处理不好，则有可能出现内存的溢出，所以对于这种方法调用形式使用时要谨慎。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java笔记：数组的定义及使用]]></title>
    <url>%2F2019%2F03%2F30%2FJava%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一维数组数组是一组相关数据的集合，一个数组实际上就是一连串的变量，数组按使用可以分为一维数组、二位数组和多维数组。 一维数组可以存放上千万个数据，并且这些数据的类型完全相同。要使用Java的数组，必须经过声明数组和分配内存给数组两个步骤，一维数组的声明与分配内存的语法结构如下： 12数据类型 数组名[] = null; // 声明一维数组数组名 = new 数据类型[长度]； // 分配内存给数组 对于数组的声明方式也可以用下面的形式： 1数据类型[] 数组名 = null; // 声明一维数组 在数组的声明格式中，“数据类型”指的是声明数组元素的数据类型，常见的类型有整型、浮点型与字符型等。“数组名”是用来统一这组相同数据类型的元素的名称，其命名规则和变量相同。数组声明后实际上在内存中保存了此数组的名称（实际上是保存对一堆内存的引用地址），接下来便要在堆内存中配置数组所需的内存。其中，“长度”是告诉编辑器所声明的数组要存放多少个元素，而关键字new则是命令编译器根据括号里的长度在堆内存中开辟一块堆内存供该数组使用，例如： 12int score[] = null; // 声明整型数组scorescore = new int[3]; // 为整型数组score分配内存空间，其元素个数为3 当声明一个整型数组score时，score可视为数组类型的变量，此时，这个变量并没有包含任何内容，编译器仅会在栈内存中分配一块内存给它，用来指向数组实体的地址的名称。声明之后，就要做堆内存分配的操作了，也就是上面第二行的语句，这一行会开辟3个可供保存整数的内存空间，并把此内存空间的参考地址赋给score变量。因为数组是引用数据类型，所以数组变量score所保存的并非是数组的实体，而是数组堆内存的参考地址。 堆栈内存的解释 数组操作中，在栈内存中保存的永远是数组的名称，只开辟了栈内存空间的数组是永远无法使用的，必须有指向的堆内存才可以使用，要想开辟新的堆内存则必须使用关键字new，然后只是将此堆内存的使用权交给了对应的栈内存空间，而且一个堆内存空间可以同时被多个栈内存空间所指向。 另外，可以在声明数组的同时分配内存空间，其格式如下： 1数据类型 数组名[] = new 数据类型[个数] 例如： 1int score[] = new int[10]; //声明一个元素个数为10的整数数组score，同时开辟一块内存空间供其使用 数组中元素的表示方法若要访问数组中的元素，可以利用索引来完成，Java的数组索引编号由0开始，以score[10]整型数组为例，score[0]代表第一个元素，而score[9]代表第10个元素，也就是最后一个元素。 数组的声明及输出： 123456789101112public class ArrayDemo01 &#123; public static void main(String[] args) &#123; int score[] = null; // 声明数组，但未开辟堆内存空间 score = new int[3]; // 为数组开辟堆内存空间 System.out.println("score[0] = " + score[0]); // 分别输出每个元素 System.out.println("score[1] = " + score[1]); // 分别输出每个元素 System.out.println("score[2] = " + score[2]); // 分别输出每个元素 for (int x = 0; x &lt; 3; x++)&#123; // 使用循环依此输出数组中的全部内容 System.out.println("score["+x+"] = " + score[x]); &#125; &#125;&#125; 程序运行结果为： 123456score[0] = 0score[1] = 0score[2] = 0score[0] = 0score[1] = 0score[2] = 0 从运行结果可以看出，对于数组的访问采用“数组名称[下标]”的方式，之前一共开辟了3个空间大小的数组，所以下标的取值为0~2，如果超出了这个下标，例如score[3]，则会出现如下错误：java.lang.ArrayIndexOutOfBoundsException:3。 此外，可以发现以上数组中的内容都是0，这是因为声明的是整型数组，而此时又没有为整型数组中的内容赋值，所以现在都是默认值，整型的默认值为0。下面的范例将为数组中的元素进行赋值并输出： 123456789101112public class ArrayDemo02 &#123; public static void main(String[] args) &#123; int score[] = null; score = new int[3]; for (int x = 0; x &lt; 3; x++)&#123; score[x] = x * 2 + 1; &#125; for (int x = 0; x &lt; 3; x++)&#123; System.out.println("score[" + x + "] = " + score[x]); &#125; &#125;&#125; 程序运行结果为： 123score[0] = 1score[1] = 3score[2] = 5 在Java中取得数组的长度（也就是数组元素的长度）可以利用“数组名称.length”的形式，会返回一个int型数据。例如 123456public class ArrayDemo03 &#123; public static void main(String[] args) &#123; int score[] = new int[3]; System.out.println("数组长度为" + score.length); &#125;&#125; 程序的运行结果为：数组长度为3 数组的静态初始化数组的内容分为动态初始化和静态初始化两种，之前所讲的代码是采用先声明数组之后为数组中的每个内容赋值的方式完成的，所以属于数组的动态初始化，也可以通过数组静态初始化，在数组声明时就指定其具体内容，只要在数组的声明格式后面加上初值的赋值即可，如下： 1数据类型 数组名[] = &#123;初值0，初值1，···，初值n&#125; 在大括号内的初值会依此指定给数组的第1、···、n个元素。此外，在声明时，并不需要将数组元素的个数列出来，编译器根据所给出的初值个数来判断数组的长度。 12345678public class ArrayDemo04 &#123; public static void main(String[] args) &#123; int score[] = &#123;91, 92, 93, 94, 95, 96&#125;; for (int x = 0; x &lt; score.length; x++)&#123; System.out.println("score[" + x + "] = " + score[x]); &#125; &#125;&#125; 程序运行结果为： 123456score[0] = 91score[1] = 92score[2] = 93score[3] = 94score[4] = 95score[5] = 96 数组应用范例 求出数组中的最大和最小值 123456789101112131415161718public class ArrayDemo05 &#123; public static void main(String[] args) &#123; int score[] = &#123;67, 89, 87, 69, 90, 100, 75, 90&#125;; // 静态初始化数组 int max = 0; // 定义变量保存最大值 int min = 0; // 定义变量保存最小值 max = min = score[0]; // 把第一个元素的内容赋值给max和min for (int x = 0; x &lt; score.length; x++)&#123; if (score[x] &gt; max)&#123; // 依此判断后续元素是否比max大 max = score[x]; // 如果大，则修改max内容 &#125; if (score[x] &lt; min)&#123; // 依此判断后续的元素是否比min小 min = score[x]; // 如果小，则修改min内容 &#125; &#125; System.out.println("最高成绩：" + max); // 输出最大值 System.out.println("最低成绩：" + min); // 输出最小值 &#125;&#125; 程序运行结果： 12最高成绩：100最低成绩：67 本程序中，首先将数组的最大和最小值都当作数组中的第一个元素，然后用for循环依此和数组后面的元素比较，如果比当前的max值大，则将该值赋给max，如果比当前的min值小，则将该值赋给min，直到数组里的元素都比较完毕，max存储了数组中的最大值，min存储了数组里的最小值。 对整型数组按照由小到大的顺序进行排列 1234567891011121314151617public class ArrayDemo06 &#123; public static void main(String[] args) &#123; int score[] = &#123;67, 89, 87, 69, 90, 100, 75, 90&#125;; // 声明数组 for (int i = 1; i &lt; score.length; i++)&#123; // 循环判断 for (int j = 0; j &lt; score.length; j++)&#123; if (score[i] &lt; score[j])&#123; // 交换位置 int temp = score[i]; score[i] = score[j]; score[j] = temp; &#125; &#125; &#125; for (int i = 0; i &lt; score.length; i++)&#123; System.out.println(score[i] + "\t"); &#125; &#125;&#125; 程序运行结果为：67 69 75 87 89 90 90 100。 以上程序采用了冒泡算法进行排序。即把数组中的每个元素进行比较，如果第i个元素大于第i+1个元素，那么就要把两个数字进行交换，这样反复的比较就可以将一个数组按照由大到小的顺序进行排序。 修改之前的代码，显示每次的排序结果 1234567891011121314151617181920212223public class ArrayDemo07 &#123; public static void main(String[] args) &#123; int score[] = &#123;67, 89, 87, 69, 90, 100, 75, 90&#125;; // 声明数组 for (int i = 1; i &lt; score.length; i++)&#123; for (int j = 0; j &lt; score.length; j++)&#123; if (score[i] &lt; score[j])&#123; int temp = score[i]; score[i] = score[j]; score[j] = temp; &#125; &#125; System.out.print("第"+i+"次排序的结果：\t"); for (int j = 0; j &lt; score.length; j++)&#123; // 循环输出 System.out.print(score[j] + "\t"); &#125; System.out.println(""); // 换行 &#125; System.out.print("最终的排序结果为：\t"); for (int i = 0; i &lt; score.length; i++)&#123; System.out.print(score[i] + "\t"); &#125; &#125;&#125; 程序运行结果为： 12345678第1次排序的结果： 67 100 87 69 89 90 75 90 第2次排序的结果： 67 87 100 69 89 90 75 90 第3次排序的结果： 67 69 87 100 89 90 75 90 第4次排序的结果： 67 69 87 89 100 90 75 90 第5次排序的结果： 67 69 87 89 90 100 75 90 第6次排序的结果： 67 69 75 87 89 90 100 90 第7次排序的结果： 67 69 75 87 89 90 90 100 最终的排序结果为： 67 69 75 87 89 90 90 100 二维数组二维数组的声明方式和一维数组类似，内存的分配也要使用关键字new完成，其声明与分配内存的格式如下： 12数据类型 数组名[][];数组名 = new 数据类型[][]; 与一维数组不同的是，二维数组在分配内存时，必须告诉编译器二维数组的行与列的个数，例如： 12int score[][]; // 声明整型数组scorescore = new int[4][3]; // 配置一块内存空间，供4行3列的整型数组score使用 同样的，也可以利用较为简洁的声明和分配内存语句： 1数据类型 数组名[][] = new 数据类型[行的个数][列的个数] 二维数组的定义及使用： 12345678910111213141516public class ArrayDemo08 &#123; public static void main(String[] args) &#123; int score[][] = new int[4][3]; // 声明并实例化二维数组 score[0][1] = 30; score[1][0] = 31; score[2][2] = 32; score[3][1] = 33; score[1][1] = 30; for (int i = 0; i &lt; score.length; i++)&#123; for (int j = 0; j &lt; score[i].length; j++)&#123; System.out.print(score[i][j] + "\t"); &#125; System.out.println(""); &#125; &#125;&#125; 程序运行结果为： 12340 30 0 31 30 0 0 0 32 0 33 0 可以看出，一维数组输出只需要使用一层循环，而二维数组全部输出则需要使用两层循环，同理，对于N维数组，则要使用N+1层循环。 二维数组也可以利用大括号进行静态初始化，只要在数组的声明格式后面再加上所赋的初值即可，格式如下： 123456数组类型 数组名[][] = &#123; &#123;第0行初值&#125;， &#123;第1行初值&#125;， ··· &#123;第n行初值&#125;&#125;； 要特别注意的是，用户不必定义数组的长度，因此，在数组名后面的中括号中不必填入任何内容。下面是二维数组声明及赋初值的例子： 123456789101112public class ArrayDemo09 &#123; public static void main(String[] args) &#123; // 静态初始化一个二维数组，每行的数组元素个数都不一样 int score[][] = &#123;&#123;67, 61&#125;, &#123;78, 89, 83&#125;, &#123;99, 100, 98, 66, 95&#125;&#125;; for (int i = 0; i &lt; score.length; i++)&#123; for (int j = 0; j &lt; score[i].length; j++)&#123; System.out.print(score[i][j] + "\t"); &#125; System.out.println(""); &#125; &#125;&#125; 程序运行结果如下： 12367 61 78 89 83 99 100 98 66 95 多维数组想要提高数组的维数，只要在声明数组时将索引与中括号再加一组即可，即三维数组的声明为int score[][][]，而四维数组的声明为int score[][][][]···，依此类推。使用多维数组时，输入、输出的方式和一维、二维数组相同，但是每多一维，嵌套循环的层数就必须多一层，所以维数越高的数组其复杂度也就越高。例如下面是三维数组的使用： 12345678910111213public class ArrayDemo10 &#123; public static void main(String[] args) &#123; // 定义一个三维数组，使用静态初始化的方式 int score[][][] = &#123;&#123;&#123;5, 1&#125;, &#123;6, 7&#125;&#125;, &#123;&#123;9, 4&#125;, &#123;8, 3&#125;&#125;&#125;; for (int i = 0; i &lt; score.length; i++)&#123; for (int j = 0; j &lt; score[i].length; j++)&#123; for (int k = 0; k &lt; score[i][j].length; k++)&#123; System.out.println("score[" + i + "][" + j + "][" + k +"]=" + score[i][j][k]); &#125; &#125; &#125; &#125;&#125; 程序运行结果为： 12345678score[0][0][0]=5score[0][0][1]=1score[0][1][0]=6score[0][1][1]=7score[1][0][0]=9score[1][0][1]=4score[1][1][0]=8score[1][1][1]=3]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java开发实战经典习题3.7]]></title>
    <url>%2F2019%2F03%2F21%2FJava%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E7%BB%8F%E5%85%B8%E4%B9%A0%E9%A2%983-7%2F</url>
    <content type="text"><![CDATA[打印出1~10000范围中所有的“水仙花数”，所谓“水仙花数”是指一个3位数，其各位数字立方和等于该数本身。例如，153就是一个“水仙花数”，因为153=（1的三次方+5的三次方+3的三次方）。123456789101112131415/**首先“水仙花数”是一个三位数，所以题目给的1~10000的范围是比较大的，可以缩小为100~999，另外需要明白这题需要用到循环结构，一次验证范围内的3位数是为“水仙花数”，我们可以采用while、do···while以及for循环中的任意一种，这里采用的是for循环。本题 一个难点是如何提取个十百位的数，我们可以采用取余算法（%）。然后用if语句判断该数是否为“水仙化数”，是就打印，不是就再执行for循环验证下一个数。*/public class test3_1 &#123; public static void main(String[] args) &#123; for (int i = 100; i &lt; 1000; i++)&#123; int m = i % 10; // 取个位数 int n = (i / 10) % 10; // 取十位数 int h = i / 100; // 取百位数 if (i == m * m * m + n * n * n + h * h * h)&#123; // 验证是否为水仙花数 System.out.println(i + "是水仙花数"); &#125; &#125; &#125;&#125; 程序运行结果为： 1234153是水仙花数370是水仙花数371是水仙花数407是水仙花数 通过代码完成两个整数内容的交换12345678910public class test3_2 &#123; public static void main(String[] args) &#123; int a = 10, b = 5; System.out.println("交换之前的内容：" + "a = " + a + "，b = " + b); a = a + b; b = a - b; a = a - b; System.out.println("交换之后的内容：" + "a = " + a + "，b = " + b); &#125;&#125; 程序运行结果为： 12交换之前的内容：a = 10，b = 5交换之后的内容：a = 5，b = 10 给定3个数字，求出这3个数字中的最大值，并将最大值输出12345678public class test3_3 &#123; public static void main(String[] args) &#123; int a = 3, b = 5, c = 4; int max = 0; max = a &gt; b ? (a &gt; c ? a : c) : (b &gt; c ? b : c); System.out.println("最大值为：" + max); &#125;&#125; 程序运行结果为： 1最大值为：5 判断某数能否被3、5、7同时整除12345678910public class test3_4 &#123; public static void main(String[] args) &#123; int num = 105; if (num%3==0 &amp;&amp; num%5==0 &amp;&amp; num%7==0) &#123; System.out.println(num + "能被3、5、7同时整除"); &#125;else &#123; System.out.println(num + "不能被3、5、7同时整除"); &#125; &#125;&#125; 程序运行结果为： 1105能被3、5、7同时整除 编写程序，分别利用while循环、do···while循环和for循环求出100~200的累加和。123456789101112131415161718192021222324252627282930313233343536373839404142/**while循环求100~200的累加和*/public class test3_5_1 &#123; public static void main(String[] args) &#123; int i = 100; int sum = 0; while (i &lt;= 200)&#123; sum += i; i++; &#125; System.out.println("100~200的累加和为：" + sum); &#125;&#125;/**do···while循环求100~200的累加和。*/public class test3_5_2 &#123; public static void main(String[] args) &#123; int i = 100; int sum = 0; do &#123; sum += i; i++; &#125;while (i &lt;= 200); System.out.println("100~200的累加和为：" + sum); &#125;&#125;/**for循环求100~200的累加和。*/public class test3_5_3 &#123; public static void main(String[] args) &#123; int sum = 0; for (int i = 100; i &lt;= 200; i++)&#123; sum += i; &#125; System.out.println("100~200的累加和为：" + sum); &#125;&#125; 编写程序Java程序，求13-23+33-43+···+973-983+993-1003的值123456789101112131415161718public class test3_6 &#123; public static void main(String[] args) &#123; int count = 1; int sum = 0; int x = 13; while (x &lt;= 1003)&#123; if (count % 2 == 1)&#123; sum += x; &#125;else &#123; sum -= x; &#125; x += 10; count++; &#125; System.out.println("3-23+33-43+···+973-983+993-1003 = " + sum); &#125;&#125; 程序运行结果为： 13-23+33-43+···+973-983+993-1003 = -500 编写一个程序，实现两个数字的交换。1234567891011/**这一题我理解为交换两位数的个位和十位。*/public class Test3_7 &#123; public static void main(String[] args) &#123; int a = 35; int n = a % 10; int m = a / 10; System.out.println("交换后的数字为：" + (n*10+m)); &#125;&#125; 编写一个程序求3个数中的最大值1参考第三题 编写一个程序，实现1~100的累加123456789public class Test3_9 &#123; public static void main(String[] args) &#123; int sum = 0; for (int i = 1; i &lt;= 100; i++)&#123; sum += i; &#125; System.out.println("1~100的累加和为：" + sum); &#125;&#125; 求1~1000之间可以同时被3、5、7整除的数字。123456789public class Test3_10 &#123; public static void main(String[] args) &#123; for (int i = 1; i &lt;= 1000; i++)&#123; if (i%3==0 &amp;&amp; i%5==0 &amp;&amp; i%7==0)&#123; System.out.println(i); &#125; &#125; &#125;&#125; 编程求1!+2!+3!+···+20!的值。1234567891011121314/**此处需要注意，阶乘是很大的数，所以不能按常规设定阶乘pro和阶乘累加和sum为int型，范围可能不够大，所以设为long型数据。*/public class Test3_11 &#123; public static void main(String[] args) &#123; long sum = 0; long pro = 1; for (int i = 1; i &lt;= 20; i++)&#123; pro *= i; // 计算每项的阶乘 sum += pro; // 计算每项阶乘的累加和 &#125; System.out.println("1!+2!+3!+...+20! = " + sum); &#125;&#125; 程序运行结果为： 11!+2!+3!+...+20! = 2561327494111820313 使用for循环打印由*组成的三角形，三角形每行的星数和行数相等12345678910111213public class Test3_12 &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt;= 4-i; j++) &#123; System.out.print(" "); // 注意print为不换行输出 &#125; for (int k = 0; k &lt;= i; k++) &#123; System.out.print("* "); // print不换行输出，注意星号后面还需要打印一个空格，不然三角形不对称 &#125; System.out.println(" "); // println换行输出 &#125; &#125;&#125; 程序运行的结果如图：]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java笔记：选择和循环语句]]></title>
    <url>%2F2019%2F03%2F18%2FJava%E7%AC%94%E8%AE%B0%EF%BC%9A%E9%80%89%E6%8B%A9%E5%92%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[程序的结构一般来说程序的结构可以分为顺序结构、选择结构以及循环结构三种，这三种结构只有一个共同点，就是它们只有一个入口，也只有一个出口，这些单一的入、出口可以让程序易读、好维护，也可以减少调试时间。 顺序结构顺序结构下的程序至上而下的逐条执行，一条语句执行完之后继续执行下一条语句，一直到程序的末尾，其结构如下图所示： 选择结构选择结构的流程图如下，这种结构可以依据判断条件的结构来决定要执行的语句，当判断条件的值为真时，就运行语句1；当判断的条件为假，则执行语句2。不论执行哪一句，最后都会回到语句3继续执行。选择结构的流程图如下： 验证选择结构： 1234567891011121314public class IfDemo &#123; public static void main(String[] args) &#123; int x = 3; int y = 10; System.out.println("======比较开始====="); if (x &gt; y)&#123; System.out.println("x比y大！"); &#125; if (x &lt; y)&#123; System.out.println("x比y小！"); &#125; System.out.println("=====比较完成====="); &#125;&#125; 程序运行结果： 123======比较开始=====x比y小！=====比较完成===== 选择结构包括if、if···else及switch语句。 if语句要根据判断的结果来执行不同的语句时，使用if语句是一个很好的选择，它会准确地判断条件成立与否，再决定是否要执行后面的语句。if语句的格式如下： 12345if (判断条件) &#123; 语句1; ··· 语句2;&#125; 当判断条件的值不满足时（true），就会逐一执行大括号里面所有的语句，否则执行大括号外的语句。 if···else语句当程序中存在含有分支的判断语句时，就可以用if···else语句处理，当判断条件成立时，即执行if语句主题；判断条件不成立时，则会执行else后面的语句主题。if···else语句的格式如下： 12345if (判断条件) &#123; 语句主体1;&#125;else &#123; 语句主体2;&#125; 例如，通过if···else语句判断一个数字是奇数还是偶数： 12345678910public class IfElseDemo &#123; public static void main(String[] args) &#123; int x = 3; if (x % 2 == 1) &#123; System.out.println("x是基数！"); &#125;else &#123; System.out.println("x是偶数！"); &#125; &#125;&#125; 三目运算符三目运算符可以等价于使用if···else进行变量赋值的语句。如下表所示： 三目运算符 意义 ?: 根据条件的成立与否来决定结果为“：”前或者“：”后的表达式 三目运算符的使用格式如下： 1变量 = 条件判断?表达式1:表达式2 该语句的意思是，当条件成立时执行表达式1，否则执行表达式2，通常会将这两个表达式之一的运算结果指定给某个变量，用if···else表示为： 12345if (条件判断)&#123; 变量x = 表达式1;&#125;else&#123; 变量x = 表达式2；&#125; 例如，使用三目运算符求出两个数字中的最大值： 123456789public class MaxDemo &#123; public static void main(String[] args) &#123; int max = 0; int x = 3; int y = 10; max = x &gt; y ? x:y; System.out.println("最大值为：" + max); &#125;&#125; if···else if···else语句如果需要在if···else中判断多个条件时，就需要if···else if···else语句了，其格式如下： 123456789if (条件判断1) &#123; 语句主体1;&#125;else if (条件判断2) &#123; 语句主体2;&#125;··· // 多个else if()语句else&#123; 语句主体3;&#125; 例如： 1234567891011121314public class MoreIfElseDemo &#123; public static void main(String[] args) &#123; int x = 3; if (x ==1) &#123; System.out.println("x的值是1！"); &#125;else if (x == 2) &#123; System.out.println("x的值是2！"); &#125;else if (x == 3) &#123; System.out.println("x的值是3！"); &#125;else &#123; System.out.println("x的值不是1、2、3中的一个！"); &#125; &#125;&#125; switch语句switch语句可以将多选一的情况简化，使程序简洁易懂，使用嵌套if···else语句最常发生的状况就是容易将if与else配对混淆，从而造成阅读及运行上的错误，而使用switch语句则可以避免这种错误发生，switch语句的格式如下： 12345678910switch (表达式) &#123; case 选择值1: 语句主体1; break； case 选择值2: 语句主体2： break; …… case 选择值n: 语句主体n; break; default: 语句主体;&#125; 特别注意的是，在switch语句中选择值只能是字符或常量，在JDK 1.5之后，switch也支持枚举类的判断。 switch语句执行的流程如下： （1） switch语句先计算括号内的表达式结果，结果是数字、字符或者枚举。 （2）根据表达式的值检测是否符合case后面的选择值，若是所有case的选择值皆不符合，则执行default所包含的语句，执行完毕即离开switch语句。 （3）如果某个case的选择值符合表达式的结果，就会执行该case所包含的语句，一直遇到break语句后才离开switch语句 （4）如果没有在case语句结尾处加上break语句，则会一直执行到switch语句的尾端才离开switch语句。 （5）若是没有定义default执行语句，则什么都不会执行，直接退出switch语句。 根据以上描述，绘制如下的switch语句的流程图： 以下程序验证了switch语句的作用： 1234567891011121314151617181920212223242526272829public class SwitchDemo01 &#123; public static void main(String[] args) &#123; int x = 3; int y = 6; char oper = '+'; switch (oper)&#123; case '+':&#123; System.out.println("x + y =" + (x + y)); break; &#125; case '-':&#123; System.out.println("x - y = " + (x - y)); break; &#125; case '*':&#123; System.out.println("x * y = " + (x * y)); break; &#125; case '/':&#123; System.out.println("x / y = " + (x / y)); break; &#125; default:&#123; System.out.println("未知操作！"); break; &#125; &#125; &#125;&#125; 程序的运行结果为：x + y = 9 break语句的作用 从以上程序可以发现，在每一个case语句后面都加上了break语句，如果不加，则switch语句会从第一个满足条件的case开始依此执行操作，例如： 12345678910111213141516171819202122232425&gt; public class SwitchDemo02 &#123;&gt; public static void main(String[] args) &#123;&gt; int x = 3;&gt; int y = 6;&gt; char oper = '+';&gt; switch (oper)&#123;&gt; case '+':&#123;&gt; System.out.println("x + y =" + (x + y));&gt; &#125;&gt; case '-':&#123;&gt; System.out.println("x - y =" + (x - y));&gt; &#125;&gt; case '*':&#123;&gt; System.out.println("x * y =" + (x * y));&gt; &#125;&gt; case '/':&#123;&gt; System.out.println("x / y =" + (x / y));&gt; &#125;&gt; default:&#123;&gt; System.out.println("未知操作！");&gt; &#125;&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; 最后得到的结果如下： 123456&gt; x + y =9&gt; x - y =-3&gt; x * y =18&gt; x / y =0&gt; 未知操作！&gt; &gt; 从运行的结果可以发现，程序在满足第一个条件后，由于没有设置break语句，所以从第一个满足条件的语句case开始依此向后继续执行，知道最后一个条件执行完毕。 循环结构while循环while是循环语句，也是判断语句，当事前不知道循环执行多少次时，就要用while循环，其格式如下： 1234567while (循环条件判断)&#123; 语句1; 语句2; ··· 语句n; 循环条件改变；&#125; 在while循环语句中，只有一个判断条件，当判断条件为真时，循环就会执行一次，再重复测试判断条件，执行循环主体，知道判断条件为假，才会跳出while循环。下面是while循环的流程及流程图： （1）第一次进入while循环前，必须先为循环控制变量（或表达式）赋起始值。 （2）根据判断条件的内容决定是否要继续执行循环，如果条件判断值为真（true），继续执行循环主体，若条件判断值为假（false），则跳出循环执行其他语句。 （3）执行完循环主体内的语句后，重新为循环控制变量（或表达式）赋值（增加或者减少），由于while循环不会自动更改循环控制变量（或表达式）的内容，所以while循环中为循环控制变量赋值的工作要自己来做，完成后再回到步骤（2）重新判断是否继续执行循环。 使用while循环进行累加操作： 1234567891011public class WhileDemo &#123; public static void main(String[] args) &#123; int x = 1; int sum = 0; while (x &lt;= 10) &#123; sum += x; x++; &#125; System.out.println("1--&gt;10累加结果为：" + sum); &#125;&#125; 程序运行结果为：1--&gt;10累加结果为：55 如果程序中没有修改循环条件（x++），那么程序将出现“死循环”的情况。 do···while循环do···while循环也是用于未知循环执行次数的情况，而while循环及do···while循环最大的不同就是进入while循环前，while语句会先测试判断条件的真假，再决定是否执行循环主体，而do···while循环则是每次都是先执行一次循环主体，然后再测试判断条件的真假，所以无论循环成立的条件是什么，使用do···while循环时，至少都会执行一次循环主体。do···while循环的格式如下： 1234567do&#123; 语句1; 语句2; ··· 语句n; 循环条件改变;&#125;while(循环条件判断) 下面描述的do···while循环的流程及流程图： （1）进入do···while循环前，要先为循环控制变量（或表达式）赋起始值。 （2）直接执行循环主体，循环主体执行完毕，才开始根据判断条件的内容决定是否继续执行循环，条件为真（true）时，继续执行循环主体；条件为假（false）时，则跳出循环，执行其他语句。 （3）执行完循环主体内的语句后，重新为循环控制变量（或表达式）赋值（增加或减少），由于do···while循环和while循环一样，不会自动更改循环控制变量（或表达式）的内容，所以在do···while循环中赋值循环控制变量的工作要由自己来做，然后再回到步骤（2）重新判断是否继续执行循环。 使用while循环进行累加操作： 1234567891011public class DoWhileDemo &#123; public static void main(String[] args) &#123; int x = 1; int sum = 0; do &#123; sum += x; x++; &#125;while (x &lt;= 10); System.out.println("1--&gt;10累加结果为：" + sum); &#125;&#125; 程序的运行结果为：1--&gt;10累加结果为：55 从程序的运行结果来看，while和do···while的结果是一样的，但是do···while与while循环不同的是do···while操作中就算条件不满足，也至少会执行一次，而while如果条件不满足，则一次也不会被执行。 for循环对于while和do···while两种循环来讲，操作时并不一定要明确地知道循环次数，而如果开发者已经明确地知道了循环次数，那么就可以使用另一种循环语句——for循环。for循环的格式如下： 12345for(赋值初值；判断条件；赋值增减量)&#123; 语句1; ··· 语句n;&#125; 下面是for循环的流程和流程图： （1）第一次进入for循环时，要为循环控制变量赋起始值。 （2）根据判断条件的内容检查是否继续执行循环，当判断条件为真（true）时，继续执行循环主体内的语句；判断条件为假（false）时，则会跳出循环，执行其他语句。 （3）执行完循环主体内的语句后，循环控制变量会根据增减量的要求更改循环控制变量的值，然后再回到步骤（2）重新判断是否继续执行循环。 使用for循环进行累加操作： 123456789public class ForDemo &#123; public static void main(String[] args) &#123; int sum = 0; for (int x = 1; x &lt;= 10; x++)&#123; sum += x; &#125; System.out.println("1--&gt;10累加结果为：" + sum); &#125;&#125; 程序的运行结果依旧如下：1--&gt;10累加结果为：55 循环的嵌套多个循环语句是可以嵌套操作的，例如下面要打印一个九九乘法表： 12345678910public class ForNestedDemo &#123; public static void main(String[] args) &#123; for (int i = 1; i &lt;= 9; i++)&#123; for (int j = 1; j &lt;= 9; j++)&#123; System.out.println(i + "*" + j + "=" + (i * j) + "\t"); // “\t”制表 &#125; System.out.println("\n"); // 换行 &#125; &#125;&#125; 程序说明： （1）i为外层循环的循环控制变量，j为内层循环的循环控制变量。 （2）当i为1时，符合外层for循环的判断条件（i&lt;9），进入另一个内层for循环体，由于是第一次进入内层循环，所以j的初值为1，符合内层for循环的判断条件（j&lt;=i）进入循环主体，输入ij的值（1\1=1），如果最后j的值任符合内层for循环的判断条件（j&lt;=i），则再次执行计算与输出的工作，直到j的值大于i时，离开内层for循环，回到外层循环。此时，i会加1成为2，符合外层for循环的判断条件，继续执行内层for循环主体，直到i的值大于9时离开嵌套循环。 循环的中断break语句break语句可以强迫程序中断循环，当程序执行到break语句时，即会离开循环，继续执行循环外的下一个语句，如果break语句出现在嵌套循环中的内层循环，则break语句只会跳出当前层的循环。下面用for循环为例，描述break语句的格式： 12345678for (初值赋值；判断条件；设增减量)&#123; 语句1； 语句2； ··· break； ··· // 若执行break语句，则此块的语句将不会被执行 语句n；&#125; 例如： 12345678910public class BreakDemo &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++)&#123; if (i == 3)&#123; break; &#125; System.out.println("i =" + i); &#125; &#125;&#125; 程序运行结果如下： 123i =0i =1i =2 从结果可以看出，当i=3时，判断语句满足，则执行了break语句跳出了整个循环，因此没有输出i=3。 continue语句continue语句可以强迫程序跳到循环的起始处，当程序运行到continue语句时，会停止运行剩余的循环主体，而是回到循环的开始处继续运行。下面以for循环为例，描述continue语句的用法： 12345678for (初值赋值；判断条件；设增减量)&#123; 语句1； 语句2； ··· continue ··· // 若执行continue语句，则此处将不会被执行 语句n；&#125; 例如： 12345678910public class ContinueDemo &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; if (i == 3)&#123; continue; &#125; System.out.println("i = " + i); &#125; &#125;&#125; 程序运行结果为： 123456789i = 0i = 1i = 2i = 4i = 5i = 6i = 7i = 8i = 9 从结果中可以发现，当i的值为3时，程序并没有输出，而是退回了循环判断处继续向下执行，所以continue只是中断了一次的循环操作。 另外，在循环语句中定义的变量属于局部变量，所谓的局部变量是指此变量只能在循环语句中使用，而在循环语句之外则无法使用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java笔记：Java中的运算符]]></title>
    <url>%2F2019%2F03%2F16%2FJava%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Java中的运算符表达式时Java的一种语句，它由操作数和操作符组成，操作数可以是常量、变量，也可以是方法，而运算符就是数学中的运算符号，如“+”、“-”、“*”、“/”等，在表达式（z+100）中，z和100都是操作数，“+”就是运算符。 Java提供了很多运算符，这些运算符除了做一般的数学运算之外，还可以做逻辑运算、位运算等。根据所使用类的不同，运算符可以分为赋值运算符、算术运算符、逻辑运算符、条件运算符以及括号运算符。 赋值运算符号想为各种不同数据类型的变量赋值时，就需要使用赋值运算符（=），等号（=）在Java中不是“等于”的意思，二十“赋值”的意思，例如： 12345678public class OperatorDemo01 &#123; public static void main(String[] args) &#123; int num = 22; System.out.println("第一次输出：num = " + num); num = num - 3; System.out.println("第二次输出：num = " + num); &#125;&#125; 第五行中，把num-3的值赋给了num，所以程序运行的结果如下： 12第一次输出：num = 22第二次输出：num = 19 当然，也可以将等号后面的值赋给其他变量，例如： 1int sum = num1 + num2; // num1与num2相加之后的值再赋给变量sum存放 一元运算符对于大部分表达式而言，运算符的前后都有操作数，但是一元运算符比较特别，它只需要一个操作数。下表列出了一元运算符的成员： 序号 一元运算符 描述 1 + 正号 2 - 负号 3 ! NOT，否 下面程序演示了3种一元运算符的使用： 12345678910public class OperatorDemo02 &#123; public static void main(String[] args) &#123; boolean b = false; // 定义boolean型数据 int x = 10; // 定义一个正数 int y = -30; // 定义一个负数 System.out.println("b = " + b + ", !b = " + !b); // 取反 System.out.println("x = " + x + ", -x = " + -x); // 使用负号 System.out.println("y = " + y + ", +y = " + +y); // 使用正号 &#125;&#125; 程序运行结果如下： 123b = false, !b = truex = 10, -x = -10y = -30, +y = -30 算术运算符常用的算术运算符如下表： 序号 算术运算符 描述 1 + 加法 2 - 减法 3 * 乘法 4 / 除法 5 % 取模（取余数） 程序中的运用如下： 1234567891011public class OperatorDemo03 &#123; public static void main(String[] args) &#123; int i = 10; int j = 3; System.out.println(i + "+" + j + "=" + (i + j)); // 加法操作 System.out.println(i + "-" + j + "=" + (i - j)); // 减法操作 System.out.println(i + "*" + j + "=" + (i * j)); // 乘法操作 System.out.println(i + "/" + j + "=" + (i / j)); // 除法操作 System.out.println(i + "%" + j + "=" + (i % j)); // 取模操作 &#125;&#125; 运行的结果如下： 1234510+3=1310-3=710*3=3010/3=310%3=1 关系运算符Java中经常会在if语句中使用关系运算符，具体格式如下： 123if (布尔表达式)&#123; 语句;&#125; 如果括号中的布尔表达式成立，就会执行{}中的语句；若是布尔表达式不成立了，则语句不会执行。常用的关系运算符如下表所示： 序号 关系运算符 描述 1 &gt; 大于 2 &lt; 小于 3 &gt;= 大于等于 4 &lt;= 小于等于 5 == 等于 6 != 不等于 需要注意的是，赋值运算符为等号（=），为了避免混淆，当使用关系运算符“等于”时，必须使用两个等号（==）表示。关系运算符在if语句中的使用如下： 12345678910111213public class OperatorDemo04 &#123; public static void main(String[] args) &#123; if (5 &gt; 2)&#123; // 判断5是否大于2 System.out.println("条件成立：5大于2"); &#125; if (true)&#123; // 判断是否为真 System.out.println("直接写的true"); &#125; if ((3 + 6) == (3 - 6)) &#123; // 判断计算结果内容是否相等 System.out.println("这是不可能成立的！"); &#125; &#125;&#125; 程序运行结果如下： 12条件成立：5大于2直接写的true 可以看到程序中最后一个if语句内的内容没有执行，因为if语句中的条件满足了，才会执行if中的内容，否则不执行。另外如果if语句之中只有一条语句，那么可以不用写“{}”，但是不建议这么写。 自增与自减运算符 序号 自增与自减运算符 描述 1 ++ 自增，变量值加1 2 — 自减，变量值减1 用自增与自减运算符可以使程序更加简洁欸，例如，声明一个int类型的变量a，在程序运行中想让它加1，语句如下： 1a = a+1; // a加1后再赋值给a 将a的值加1后再赋给a存放，也可以利用自增运算符“++”写出语义相同但是语句更简洁的语句： 1a++; // a加1后再赋值给a存放，语句更简洁 在程序中还可以看到另一种自增运算符“++”的用法，就是将自增运算符“++”写在变量的前面，如++a，这就和a++所表示的意义完全不一样。a++会先执行整个语句后再将a的值加1，而++b则先把b的值加1后，再执行整个语句。 1234567891011121314public class OperatorDemo05 &#123; public static void main(String[] args) &#123; int a = 3, b = 3; int x = 6, y = 6; System.out.println("a = " + a); // 输出变量a的值 System.out.println("\t a++ = " + (a++) + ", a = " + a); // 先执行后自增 System.out.println("b = " + b); // 输出变量b的值 System.out.println("\t ++b = " + (++b) + ", b = " + b); // 先自增后执行 System.out.println("x = " + x); // 输出变量x的值 System.out.println("\t x-- = " + (x--) + ", x = " + x); // 先执行后自减 System.out.println("y = " + y); // 输出变量y的值 System.out.println("\t --y = " + (--y) + ", y = " + y); // 先自减后执行 &#125;&#125; 程序运行结果如下： 12345678a = 3 a++ = 3, a = 4b = 3 ++b = 4, b = 4x = 6 x-- = 6, x = 5y = 6 --y = 5, y = 5 逻辑运算符使用逻辑运算符可以连接多个逻辑运算，常用的逻辑运算符如下表： 序号 逻辑运算符 描述 1 &amp; AND，与 2 &amp;&amp; 短路与 3 &#124; OR，或 4 &#124;&#124; 短路或 当使用逻辑运算符“&amp;&amp;”时，运算符前后的两个操作数的返回值皆为真，运算的结果才会为真；使用逻辑运算“||”时，运算符前后的两个操作数的返回值只要有一个为真，运算结果就为真。并存在以下规律： 12345678910public class OperatorDemo06 &#123; public static void main(String[] args) &#123; boolean a = true; boolean b = false; System.out.println("a || b = " + (a || b)); System.out.println("a | b = " + (a | b)); System.out.println("a &amp;&amp; b = " + (a &amp;&amp; b)); System.out.println("a &amp; b = " + (a &amp; b)); &#125;&#125; 程序运行结果为： 1234a || b = truea | b = truea &amp;&amp; b = falsea &amp; b = false 根据对逻辑操作理解，可以总结以下规律： 对于与操作来说，如果第一个条件为假，后面的条件不管是真是假，最终的结果都是假。 对于或操作来说，如果第一个条件为真，后面的条件不管是真是假，最终的结果都是真。 也就是说，对于与和或来说，最先满足的条件就是一个关键性的条件，所以在Java中设置了短路与和短路或，对于短路与和与、短路或和或有以下区别： 对于与来说，要求所有的条件都判断，而如果使用短路与，第一个条件又为false，则后面的条件不需要再判断。 对于或来说，要求所有的条件都判断，而如果使用短路或，第一个条件又为true，则后面的条件不需要再判断。 下面通过三段代码来理解以上两点： 测试代码（一）：观察被除数为0的情况 123456public class OperatorDemo07 &#123; public static void main(String[] args) &#123; int x = 10 / 0; System.out.println("x = " + x); // 错误，被除数为0 &#125;&#125; 该段程序运行之后会出现以下错误，即错误的根本原因在于除数为0： Exception in thread “main” java.lang.ArithmeticException: / by zero 测试代码（二）：验证“&amp;”的作用 1234567public class OperatorDemo08 &#123; public static void main(String[] args) &#123; if (10 != 10 &amp; 10 /0 == 0) &#123; // 非短路与 System.out.println("条件满足"); &#125; &#125;&#125; 程序运行后，又出现了下面的错误提示： Exception in thread “main” java.lang.ArithmeticException: / by zero 造成以上错误的根本原因在于“与”操作要把所有的条件进行判断，所以在计算10/0时就出现了错误。 测试代码（三）：验证“&amp;&amp;”的作用 1234567public class OperatorDemo09 &#123; public static void main(String[] args) &#123; if (10 != 10 &amp;&amp; 10/0 == 0) &#123; // 短路与 System.out.println("条件满足"); &#125; &#125;&#125; 该程序运行后，没有出现上面的错误，因为短路与判断第一个条件就为false，那么之后的条件就不用判断了，这就是短路与的作用。短路或和或也是同样的原理。 括号运算符括号“()”也是Java的运算符，用于提高括号中表达式的优先级。 位运算符Java中支持位运算操作，位运算操作是指进行二进制位的运算，在Java中支持的位运算符如下表所示： 序号 位运算符 描述 1 &amp; 按位与 2 &#124; 按位或 3 ^ 异或（相同为0，不同为1） 4 ~ 取反 5 &lt;&lt; 左移位 6 &gt;&gt; 右移位 7 &gt;&gt;&gt; 无符号右移位 在Java中所有的数据都是以二进制的形式进行运算的，每一位二进制进行与、或、异或操作的结果如下表所示： 序号 二进制数1 二进制数2 与操作（&amp;） 或操作（&#124;） 异或操作（^） 1 0 0 0 0 0 2 0 1 0 1 1 3 1 0 0 1 1 4 1 1 1 1 0 下面通过一段代码来观察位运算符： 123456789public class OperatorDemo10 &#123; public static void main(String[] args) &#123; int x = 3; // 3的二进制数据：00000000 00000000 00000000 00000011 int y = 6; // 6的二进制数据：00000000 00000000 00000000 00000110 System.out.println(x &amp; y); // 与操作的结果： 00000000 00000000 00000000 00000010 System.out.println(x | y); // 或操作的结果： 00000000 00000000 00000000 00000111 System.out.println(x ^ y); // 异或操作结果： 00000000 00000000 00000000 00000101 &#125;&#125; 运行结果如下：123275 在计算机的数据表示中只定义了整数的表现形式，并没有定义负数的表现形式，所以，负数一般用补码的形式表示，整数的原码、反码、补码都相同，负数的反码除符号位为1外，其余位取相反；补码就是“反码+1”。 求出负数的反码： 123456public class OperatorDemo16 &#123; public static void main(String[] args) &#123; int x = -3; // -3的二进制数据：11111111 11111111 11111111 11111101 System.out.println(x + "的反码时：" + ~x); &#125;&#125; 程序输出的结果位2（二进制数据：00000000 00000000 00000000 00000010），因为计算机中负数都是使用补码的形式计算，补码的计算是“反码+1”，然后对-3进行反码，操作过程如下所示： 123410000000 00000000 00000000 00000011 // -3原码11111111 11111111 11111111 11111100 // -3反码11111111 11111111 11111111 11111101 // -3补码 = -3反码 + 100000000 00000000 00000000 00000010 // ~-3 在Java中也提供了左移“&lt;&lt;”和右移“&gt;&gt;”两种操作。左移操作是将运算数的二进制嘛整体左移指定位数，左移之后的空位由0来填充，例如： 123456public class OperatorDemo17 &#123; public static void main(String[] args) &#123; int x = 3; // 3的二进制数据： 00000000 00000000 00000000 00000011 System.out.println(x + "左移2位之后的内容：" + (x &lt;&lt; 2)); &#125;&#125; 程序输出为： 13左移2位之后的内容：12 // 12二进制数：00000000 00000000 00000000 00001100 右移操作“&gt;&gt;”是将运算数的二进制码整体右移，右移之后的空位以符号位填充，即如果整数就用0填充，如果是负数则用1填充，例如： 12345678public class OperatorDemo18 &#123; public static void main(String[] args) &#123; int x = 3; // 3的二进制数据：00000000 00000000 00000000 00000011 int y = -3; // -3的二进制数： 11111111 11111111 11111111 11111101 System.out.println(x + "右移2位之后的内容：" + (x &gt;&gt; 2)); System.out.println(y + "右移2位之后的内容：" + (y &gt;&gt; 2)); &#125;&#125; 程序运行结果： 123右移2位之后的内容：0 // 3右移两位之后的二进制：00000000 00000000 00000000 00000000-3右移2位之后的内容：-1 // -3右移两位后的二进制： 11111111 11111111 11111111 11111111 因为-3右移后的二进制依然是负数，负数用的补码表示，而补码=反码+1，所以求出对应的反码=补码-1，原码也可以根据反码求出： -3右移两位后的二进制补码：11111111 11111111 11111111 11111111 反码 = 补码-1，即补码为： 11111111 11111111 11111111 11111110 -3右移两位后的二进制原码：10000000 00000000 00000000 00000001 以上右移操作是带符号位的右移操作，Java也提供无符号位的右移操作“&gt;&gt;&gt;”，即右移后的空位由0来填充，例如： 12345678public class OperatorDemo19 &#123; public static void main(String[] args) &#123; int x = 3; // 3的二进制数据：00000000 00000000 00000000 00000011 int y = -3; // -3的二进制数： 11111111 11111111 11111111 11111101 System.out.println(x + "右移2位后的内容：" + (x &gt;&gt;&gt; 2)); System.out.println(y + "右移2位后的内容：" + (y &gt;&gt;&gt; 2)); &#125;&#125; 程序运行结果： 123右移2位后的内容：0 // 3右移两位之后的二进制：00000000 00000000 00000000 00000000-3右移2位后的内容：1073741823 // 不带符号位-3右移两位： 00111111 11111111 11111111 11111111 运算符的优先级 优先级 运算符 类 结合性 1 () 括号运算符 由左至右 1 [] 方括号运算符 由左至右 2 !、+（正号）、-（负号） 一元运算符 由右至左 2 ~ 位逻辑运算符 由右至左 2 ++、— 自增与自减运算符 由右至左 3 *、/、% 算术运算符 由左至右 4 +、- 算术运算符 由左至右 5 &lt;&lt;、&gt;&gt; 位左移、位右移运算符 由左至右 6 &gt;、&gt;=、&lt;、&lt;= 关系运算符 由左至右 7 ==、!= 关系运算符 由左至右 8 &amp;（位运算符AND） 位逻辑运算符 由左至右 9 ^（位运算符XOR） 位逻辑运算符 由左至右 10 &#124;（位运算符OR） 位逻辑运算符 由左至右 11 &amp;&amp; 逻辑运算符 由左至右 12 &#124;&#124; 逻辑运算符 由左至右 13 ?: 三目运算符 由右至左 当使用同一级运算符的时候，结合性非常重要，因为它决定了谁会被先处理，即在相同优先级的运算符中，根据结合性来处理操作数。对于以上优先级没有必要完全记下，可以多使用括号改变优先级。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java笔记：Java中的数据类型]]></title>
    <url>%2F2019%2F03%2F15%2FJava%E7%AC%94%E8%AE%B0%EF%BC%9AJava%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[数据类型划分Java的数据类型可以分为基本数据类型和应用数据类型两类，原始数据类型也称为基本数据类型，包括最基本的boolean、byte、char、short、int、long、float、与double等类型；引用数据类型以一种特殊的方式指向变量的实体，类似于C/C++的指针，这类变量在声明时不会分配内存，必须另外开辟内存空间的操作，如字符串和数组均属于这种数据类型。Java的数据类型如下图所示： f(n) \begin{cases} 基本数据类型 \begin{cases} 数值型 \begin{cases} 整数类型（byte、short、int、long）\\ 浮点类型（float、double） \end{cases}\\ 字符型(char)\\ 布尔型（boolean） \end{cases}\\ 引用数据类型 \begin{cases} 类（class）\\ 接口（interface）\\ 数组 \end{cases} \end{cases}基本数据类型Java中基本的数据类型如下表所示： 序号 数据类型 大小/位 1 long（长整数） 64 2 int（整数） 32 3 short（短整数） 16 4 byte（位） 8 5 char（字符） 16 6 float（单精度） 32 7 double（双精度） 64 8 Boolean（布尔） — 整数类型整数类型可以分为long、int、short、及byte 4种，其中long为64位，即8个字节（bytes），int为32位，即4个字节，short为16位，也就是2个字节，byte为8位，也就是1个字节。例如，sum是一个短整型变量，在程序中作出如下声明： 1short num; //声明sum为短整型 经过声明之后，Java会在可使用的内存空间中寻找一个占有两个字节的块供sum变量使用。在Java中对于一个整型常量，其默认类型为int型，所以一般在声明常量时不要超过int数据类型的范围。 数据溢出当整数的数据大小超过其类型可以表示的范围，而程序中又没有做数值范围的检查时，一个整型变量所输出的值将会发生紊乱，且不是预期的运行结果。例如下面的程序中声明了一个整型的数，并把它赋值为整型所可以表示范围的最大值，然后将它分别加1和加2： 12345678class DataDemo01&#123; public static void main(String[] args)&#123; int max = Integer.MAX_VALUE; // 得到整型的最大值 System.out.println("整型的最大值：" + max); // 输出最大值 System.out.println("整型最大值 + 1：" + (max + 1)); // 最大值加1 System.out.println("整型最大值 + 2：" + (max + 2)); // 最大值加2 &#125;&#125; 程序的运行结果如下： 123整型的最大值：2147483647整型最大值+1：-2147483648整型最大值+2：-2147483647 int型的范围为-2147483648~2147483647，从输出结果可以看出，当最大值2147483647加上1之后，结果变成了最小值；当最大值加上2时，结果变成了次小值，这就是数据类型的溢出。为了避免int类型的溢出，可以再该表达式中的任一常量后加上大写的L，或者在变量前面加上long，做强制类型的转换，例如： 123456789ublic class DataDemo02 &#123; public static void main(String[] args)&#123; int max = Integer.MAX_VALUE; // 整型最大值 System.out.println("整型的最大值：" + max); // 输出最大值 System.out.println("整型最大值+1：" + (max+1)); // 最大值加1 System.out.println("整型最大值+2：" + (max+2L)); // 变成long型 System.out.println("整型最大值+2：" + ((long)max+2)); // 转换成long型 &#125;&#125; 程序运行的结果如下： 1234整型的最大值：2147483647整型最大值+1：-2147483648整型最大值+2：2147483649整型最大值+2：2147483649 处理int型的溢出，可以采用强制类型转换方式，但是对于long型的溢出，就没有处理办法了，此时就需要在程序中加上变量值的界限检查，在运行时才不会发生错误。 字符类型字符类型在内存中占两个字节，可以用来保存英文字母等字符。给字符变量赋值可以使用数字和字符，它们都能使程序正确的运行，例如，Java中使用Unicode编码系统，Unicode中小写的a是以97表示的，所以，如果要给一个字符变量赋值为a，可以使用小写“a”，也可以使用数字97，需要注意的是，字符要用一队单引号（’ ‘）括起。程序中字符类型的声明如下： 1char ch = 'a'; // 声明ch为字符型，其值为a 在程序中输出一个包括双引号的字符串时，可以把字符变量赋值为转义字符，再将它输出，即：再程序中声明一个字符类型变量ch，然后把ch设置为“\\””，再进行输出操作，或者，也可以直接再要输出的字符穿中加入特殊的转义字符。常用的转义字符如下表： 序号 转义字符 描述 1 \f 换页 2 \\ 反斜线 3 \b 倒退一格 4 \’ 单引号 5 \r 归位 6 \” 双引号 7 \t 制表符Tab 8 \n 换行 例如： 123456789public class DataDemo03 &#123; public static void main(String[] args) &#123; char ch1 = '\"'; // 定义转义字符 char ch2 = '\\'; // 定义转义字符 System.out.println("ch1 = " + ch1); // 打印输出 System.out.println("ch2 = " + ch2); // 打印输出 System.out.println("\"Hello World\""); // 直接输出转义字符 &#125;&#125; 程序输出如下： 123ch1 = &quot;ch2 = \&quot;Hello World&quot; 浮点数类型与双精度浮点数类型在Java中，带有小数点的数据类型称为浮点数类型（float），其长度为32个字节，当浮点数的表示范围不够大时，还有一种双精度（double）浮点数可以使用，双精度浮点数类型的长度为64个字节。两种数据类型的声明如下： 12double num; // 声明num为双精度浮点型变量float sum = 3.0f； // 声明sum为浮点型变量，其初值为3.0 需要注意的是，在Java中使用浮点型数值时，默认类型时double，在数值后面可以加上D或者d，作为double类型的标识，在数据后面加上F或者f，则作为float类型的标识。若什么都没加，Java会将该数据默认为double类型。 布尔类型布尔（boolean）类型的变量只有true（真）和false（假）两种，程序中对布尔类型的数据声明如下： 1boolean flag = true; // 声明布尔变量flag，并赋值为true 数据类型转换数据类型的转换方式可以分为自动类型转换及强制类型转换两种。 自动转换在程序中已经定义好了数据类型的变量，若要用另一种数据类习表示时，Java会在下列条件皆成立时，自动做数据类型的转换： ​ （1） 转换前的数据类型与转换后的类型兼容。 ​ （2） 转换后的数据类型的表示范围比转换前的类型大。 例如，将short类型的变量a转换成int类型，由于short与int皆为整数类型，符合上述条件（1）；而int的表示范围比short大，符合条件（2），因此Java会自动将原为short类型的变量a转换成int类型。 值得注意的是，类型的转换只限该行语句，并不会影响原先所定义的变量的类型，而且通过自动类型的转换可以保证数据的精确度，它不会因为转换而损失数据内容，这种类型的转换方式也称为扩大转换。 以扩大转换来看，字符和整数是可以使用自动类型转换的，整数和浮点数亦是兼容的，但是由于boolean类型只能存放true或false，与整数及字符是不兼容的，因此不能做类型的转换。下面介绍当两个数其中一个为浮点数时，其运算结果会怎么变化： 123456789public class DataDemo04 &#123; public static void main(String[] args) &#123; int x = 30; float y = 22.19f; System.out.println(&quot;x/y = &quot; + (x/y)); System.out.println(&quot;10/3.5 = &quot; + (10/3.5)); System.out.println(&quot;10/3 = &quot; + (10/3)); &#125;&#125; 程序运行结果为： 123x/y = 1.351960310/3.5 = 2.85714285714285710/3 = 3 从输出结果来看，int类型与float类型进行计算之后，输出的结果会变成float类型，一个整型常量和一个浮点型常量进行计算之后，结果也会变成一个浮点数据，而如果两个int型的常量进行计算，最终结果也时int型，而其小树部分将会被忽略。也就是说，假设有一个整数和双精度浮点数作运算时，Java会把整数转换成双精度浮点数后再做运算，运算结果也会变成双精度浮点数。 强制转换当两个整数进行运算时，其运算结果也会是整数，例如，做除法运算8/3，其结果为整数2，而不是实际的2.33333···，因此，在Java中若是想要得到的计算结果是浮点数时，就必须将数据类型做强制性的转换，转换语法如下： 1（要转换的数据类型） 变量名称； 因为这种强制类型的转换时直接变写在程序代码中的，所以也称为显示转换。强制转换例子如下： 12345678public class DataDemo05 &#123; public static void main(String[] args) &#123; float f = 30.3f; int x = (int)f; System.out.println("x = " + x); System.out.println("10 / 3 = " + ((float)10 /3 )); &#125;&#125; 程序运行结果如下： 12x = 3010 / 3 = 3.3333333 在程序中，首先将一个浮点型的变量f的内容赋给了int型变量x，因为int数据类型的长度小于float类型的长度，所以此处需要进行强制转换。程序的最后使用了两个整型常量进行计算，但是因为将其中一个整型变量变为了float类型，所以在计算时会强制把其他的整型也变成float类型，最后计算结果也就是包含小数的。 和自动转换一样，强制转换并不会影响原先定义的变量的类型，运行时只会将强制转换的那行语句进行变量的数据类型转换。此外，若是将一个超出该变量可表示范围的值赋值给这个变量，这种转换称为缩小转换，这种转换可能会丢失数据精度，因此Java并不会主动进行这种类型的转换，此时就必须做强制转换。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
</search>
