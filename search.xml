<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java运算符表达式以及语句]]></title>
    <url>%2F2019%2F03%2F16%2FJava%E8%BF%90%E7%AE%97%E7%AC%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BB%A5%E5%8F%8A%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java数据类型]]></title>
    <url>%2F2019%2F03%2F15%2FJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[数据类型划分Java的数据类型可以分为基本数据类型和应用数据类型两类，原始数据类型也称为基本数据类型，包括最基本的boolean、byte、char、short、int、long、float、与double等类型；引用数据类型以一种特殊的方式指向变量的实体，类似于C/C++的指针，这类变量在声明时不会分配内存，必须另外开辟内存空间的操作，如字符串和数组均属于这种数据类型。Java的数据类型如下图所示： f(n) \begin{cases} 基本数据类型 \begin{cases} 数值型 \begin{cases} 整数类型（byte、short、int、long）\\ 浮点类型（float、double） \end{cases}\\ 字符型(char)\\ 布尔型（boolean） \end{cases}\\ 引用数据类型 \begin{cases} 类（class）\\ 接口（interface）\\ 数组 \end{cases} \end{cases}基本数据类型Java中基本的数据类型如下表所示： 序号 数据类型 大小/位 1 long（长整数） 64 2 int（整数） 32 3 short（短整数） 16 4 byte（位） 8 5 char（字符） 16 6 float（单精度） 32 7 double（双精度） 64 8 Boolean（布尔） — 整数类型整数类型可以分为long、int、short、及byte 4种，其中long为64位，即8个字节（bytes），int为32位，即4个字节，short为16位，也就是2个字节，byte为8位，也就是1个字节。例如，sum是一个短整型变量，在程序中作出如下声明： 1short num; //声明sum为短整型 经过声明之后，Java会在可使用的内存空间中寻找一个占有两个字节的块供sum变量使用。在Java中对于一个整型常量，其默认类型为int型，所以一般在声明常量时不要超过int数据类型的范围。 数据溢出当整数的数据大小超过其类型可以表示的范围，而程序中又没有做数值范围的检查时，一个整型变量所输出的值将会发生紊乱，且不是预期的运行结果。例如下面的程序中声明了一个整型的数，并把它赋值为整型所可以表示范围的最大值，然后将它分别加1和加2： 12345678class DataDemo01&#123; public static void main(String[] args)&#123; int max = Integer.MAX_VALUE; // 得到整型的最大值 System.out.println("整型的最大值：" + max); // 输出最大值 System.out.println("整型最大值 + 1：" + (max + 1)); // 最大值加1 System.out.println("整型最大值 + 2：" + (max + 2)); // 最大值加2 &#125;&#125; 程序的运行结果如下： 123整型的最大值：2147483647整型最大值+1：-2147483648整型最大值+2：-2147483647 int型的范围为-2147483648~2147483647，从输出结果可以看出，当最大值2147483647加上1之后，结果变成了最小值；当最大值加上2时，结果变成了次小值，这就是数据类型的溢出。为了避免int类型的溢出，可以再该表达式中的任一常量后加上大写的L，或者在变量前面加上long，做强制类型的转换，例如： 123456789ublic class DataDemo02 &#123; public static void main(String[] args)&#123; int max = Integer.MAX_VALUE; // 整型最大值 System.out.println("整型的最大值：" + max); // 输出最大值 System.out.println("整型最大值+1：" + (max+1)); // 最大值加1 System.out.println("整型最大值+2：" + (max+2L)); // 变成long型 System.out.println("整型最大值+2：" + ((long)max+2)); // 转换成long型 &#125;&#125; 程序运行的结果如下： 1234整型的最大值：2147483647整型最大值+1：-2147483648整型最大值+2：2147483649整型最大值+2：2147483649 处理int型的溢出，可以采用强制类型转换方式，但是对于long型的溢出，就没有处理办法了，此时就需要在程序中加上变量值的界限检查，在运行时才不会发生错误。 字符类型字符类型在内存中占两个字节，可以用来保存英文字母等字符。给字符变量赋值可以使用数字和字符，它们都能使程序正确的运行，例如，Java中使用Unicode编码系统，Unicode中小写的a是以97表示的，所以，如果要给一个字符变量赋值为a，可以使用小写“a”，也可以使用数字97，需要注意的是，字符要用一队单引号（’ ‘）括起。程序中字符类型的声明如下： 1char ch = 'a'; // 声明ch为字符型，其值为a 在程序中输出一个包括双引号的字符串时，可以把字符变量赋值为转义字符，再将它输出，即：再程序中声明一个字符类型变量ch，然后把ch设置为“\\””，再进行输出操作，或者，也可以直接再要输出的字符穿中加入特殊的转义字符。常用的转义字符如下表： 序号 转义字符 描述 1 \f 换页 2 \\ 反斜线 3 \b 倒退一格 4 \’ 单引号 5 \r 归位 6 \” 双引号 7 \t 制表符Tab 8 \n 换行 例如： 123456789public class DataDemo03 &#123; public static void main(String[] args) &#123; char ch1 = '\"'; // 定义转义字符 char ch2 = '\\'; // 定义转义字符 System.out.println("ch1 = " + ch1); // 打印输出 System.out.println("ch2 = " + ch2); // 打印输出 System.out.println("\"Hello World\""); // 直接输出转义字符 &#125;&#125; 程序输出如下： 123ch1 = &quot;ch2 = \&quot;Hello World&quot; 浮点数类型与双精度浮点数类型在Java中，带有小数点的数据类型称为浮点数类型（float），其长度为32个字节，当浮点数的表示范围不够大时，还有一种双精度（double）浮点数可以使用，双精度浮点数类型的长度为64个字节。两种数据类型的声明如下： 12double num; // 声明num为双精度浮点型变量float sum = 3.0f； // 声明sum为浮点型变量，其初值为3.0 需要注意的是，在Java中使用浮点型数值时，默认类型时double，在数值后面可以加上D或者d，作为double类型的标识，在数据后面加上F或者f，则作为float类型的标识。若什么都没加，Java会将该数据默认为double类型。 布尔类型布尔（boolean）类型的变量只有true（真）和false（假）两种，程序中对布尔类型的数据声明如下： 1boolean flag = true; // 声明布尔变量flag，并赋值为true 数据类型转换数据类型的转换方式可以分为自动类型转换及强制类型转换两种。 自动转换在程序中已经定义好了数据类型的变量，若要用另一种数据类习表示时，Java会在下列条件皆成立时，自动做数据类型的转换： ​ （1） 转换前的数据类型与转换后的类型兼容。 ​ （2） 转换后的数据类型的表示范围比转换前的类型大。 例如，将short类型的变量a转换成int类型，由于short与int皆为整数类型，符合上述条件（1）；而int的表示范围比short大，符合条件（2），因此Java会自动将原为short类型的变量a转换成int类型。 值得注意的是，类型的转换只限该行语句，并不会影响原先所定义的变量的类型，而且通过自动类型的转换可以保证数据的精确度，它不会因为转换而损失数据内容，这种类型的转换方式也称为扩大转换。 以扩大转换来看，字符和整数是可以使用自动类型转换的，整数和浮点数亦是兼容的，但是由于boolean类型只能存放true或false，与整数及字符是不兼容的，因此不能做类型的转换。下面介绍当两个数其中一个为浮点数时，其运算结果会怎么变化： 123456789public class DataDemo04 &#123; public static void main(String[] args) &#123; int x = 30; float y = 22.19f; System.out.println(&quot;x/y = &quot; + (x/y)); System.out.println(&quot;10/3.5 = &quot; + (10/3.5)); System.out.println(&quot;10/3 = &quot; + (10/3)); &#125;&#125; 程序运行结果为： 123x/y = 1.351960310/3.5 = 2.85714285714285710/3 = 3 从输出结果来看，int类型与float类型进行计算之后，输出的结果会变成float类型，一个整型常量和一个浮点型常量进行计算之后，结果也会变成一个浮点数据，而如果两个int型的常量进行计算，最终结果也时int型，而其小树部分将会被忽略。也就是说，假设有一个整数和双精度浮点数作运算时，Java会把整数转换成双精度浮点数后再做运算，运算结果也会变成双精度浮点数。 强制转换当两个整数进行运算时，其运算结果也会是整数，例如，做除法运算8/3，其结果为整数2，而不是实际的2.33333···，因此，在Java中若是想要得到的计算结果是浮点数时，就必须将数据类型做强制性的转换，转换语法如下： 1（要转换的数据类型） 变量名称； 因为这种强制类型的转换时直接变写在程序代码中的，所以也称为显示转换。强制转换例子如下： 12345678public class DataDemo05 &#123; public static void main(String[] args) &#123; float f = 30.3f; int x = (int)f; System.out.println("x = " + x); System.out.println("10 / 3 = " + ((float)10 /3 )); &#125;&#125; 程序运行结果如下： 12x = 3010 / 3 = 3.3333333 在程序中，首先将一个浮点型的变量f的内容赋给了int型变量x，因为int数据类型的长度小于float类型的长度，所以此处需要进行强制转换。程序的最后使用了两个整型常量进行计算，但是因为将其中一个整型变量变为了float类型，所以在计算时会强制把其他的整型也变成float类型，最后计算结果也就是包含小数的。 和自动转换一样，强制转换并不会影响原先定义的变量的类型，运行时只会将强制转换的那行语句进行变量的数据类型转换。此外，若是将一个超出该变量可表示范围的值赋值给这个变量，这种转换称为缩小转换，这种转换可能会丢失数据精度，因此Java并不会主动进行这种类型的转换，此时就必须做强制转换。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
