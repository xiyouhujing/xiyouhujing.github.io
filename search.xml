<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java数据类型]]></title>
    <url>%2F2019%2F03%2F15%2FJava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[数据类型划分Java的数据类型可以分为基本数据类型和应用数据类型两类，原始数据类型也称为基本数据类型，包括最基本的boolean、byte、char、short、int、long、float、与double等类型；引用数据类型以一种特殊的方式指向变量的实体，类似于C/C++的指针，这类变量在声明时不会分配内存，必须另外开辟内存空间的操作，如字符串和数组均属于这种数据类型。Java的数据类型如下图所示： f(n) \begin{cases} 基本数据类型 \begin{cases} 数值型 \begin{cases} 整数类型（byte、short、int、long）\\ 浮点类型（float、double） \end{cases}\\ 字符型(char)\\ 布尔型（boolean） \end{cases}\\ 引用数据类型 \begin{cases} 类（class）\\ 接口（interface）\\ 数组 \end{cases} \end{cases}基本数据类型Java中基本的数据类型如下表所示： 序号 数据类型 大小/位 1 long（长整数） 64 2 int（整数） 32 3 short（短整数） 16 4 byte（位） 8 5 char（字符） 16 6 float（单精度） 32 7 double（双精度） 64 8 Boolean（布尔） — 整数类型整数类型可以分为long、int、short、及byte 4种，其中long为64位，即8个字节（bytes），int为32位，即4个字节，short为16位，也就是2个字节，byte为8位，也就是1个字节。例如，sum是一个短整型变量，在程序中作出如下声明： 1short num; //声明sum为短整型 经过声明之后，Java会在可使用的内存空间中寻找一个占有两个字节的块供sum变量使用。在Java中对于一个整型常量，其默认类型为int型，所以一般在声明常量时不要超过int数据类型的范围。 数据溢出当整数的数据大小超过其类型可以表示的范围，而程序中又没有做数值范围的检查时，一个整型变量所输出的值将会发生紊乱，且不是预期的运行结果。例如下面的程序中声明了一个整型的数，并把它赋值为整型所可以表示范围的最大值，然后将它分别加1和加2： 12345678class DataDemo01&#123; public static void main(String[] args)&#123; int max = Integer.MAX_VALUE; // 得到整型的最大值 System.out.println("整型的最大值：" + max); // 输出最大值 System.out.println("整型最大值 + 1：" + (max + 1)); // 最大值加1 System.out.println("整型最大值 + 2：" + (max + 2)); // 最大值加2 &#125;&#125; 程序的运行结果如下： 123整型的最大值：2147483647整型最大值+1：-2147483648整型最大值+2：-2147483647 int型的范围为-2147483648~2147483647，从输出结果可以看出，当最大值2147483647加上1之后，结果变成了最小值；当最大值加上2时，结果变成了次小值，这就是数据类型的溢出。为了避免int类型的溢出，可以再该表达式中的任一常量后加上大写的L，或者在变量前面加上long，做强制类型的转换，例如： 123456789ublic class DataDemo02 &#123; public static void main(String[] args)&#123; int max = Integer.MAX_VALUE; // 整型最大值 System.out.println("整型的最大值：" + max); // 输出最大值 System.out.println("整型最大值+1：" + (max+1)); // 最大值加1 System.out.println("整型最大值+2：" + (max+2L)); // 变成long型 System.out.println("整型最大值+2：" + ((long)max+2)); // 转换成long型 &#125;&#125; 程序运行的结果如下： 1234整型的最大值：2147483647整型最大值+1：-2147483648整型最大值+2：2147483649整型最大值+2：2147483649 处理int型的溢出，可以采用强制类型转换方式，但是对于long型的溢出，就没有处理办法了，此时就需要在程序中加上变量值的界限检查，在运行时才不会发生错误。 字符类型字符类型在内存中占两个字节，可以用来保存英文字母等字符。给字符变量赋值可以使用数字和字符，它们都能使程序正确的运行，例如，Java中使用Unicode编码系统，Unicode中小写的a是以97表示的，所以，如果要给一个字符变量赋值为a，可以使用小写“a”，也可以使用数字97，需要注意的是，字符要用一队单引号（’ ‘）括起。程序中字符类型的声明如下： 1char ch = 'a'; // 声明ch为字符型，其值为a 在程序中输出一个包括双引号的字符串时，可以把字符变量赋值为转义字符，再将它输出，即：再程序中声明一个字符类型变量ch，然后把ch设置为“\\””，再进行输出操作，或者，也可以直接再要输出的字符穿中加入特殊的转义字符。常用的转义字符如下表： 序号 转义字符 描述 1 \f 换页 2 \\ 反斜线 3 \b 倒退一格 4 \’ 单引号 5 \r 归位 6 \” 双引号 7 \t 制表符Tab 8 \n 换行 例如： 123456789public class DataDemo03 &#123; public static void main(String[] args) &#123; char ch1 = '\"'; // 定义转义字符 char ch2 = '\\'; // 定义转义字符 System.out.println("ch1 = " + ch1); // 打印输出 System.out.println("ch2 = " + ch2); // 打印输出 System.out.println("\"Hello World\""); // 直接输出转义字符 &#125;&#125; 程序输出如下： 123ch1 = &quot;ch2 = \&quot;Hello World&quot; 浮点数类型与双精度浮点数类型在Java中，带有小数点的数据类型称为浮点数类型（float），其长度为32个字节，当浮点数的表示范围不够大时，还有一种双精度（double）浮点数可以使用，双精度浮点数类型的长度为64个字节。两种数据类型的声明如下： 12double num; // 声明num为双精度浮点型变量float sum = 3.0f； // 声明sum为浮点型变量，其初值为3.0 需要注意的是，在Java中使用浮点型数值时，默认类型时double，在数值后面可以加上D或者d， 数据类型转换]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
