---
title: Java笔记：Java中的运算符
date: 2019-03-16 20:01:55
categories: Java
tags:
- java基础
mathjax: true
---

**Java中的运算符**
> 表达式是Java的一种语句，它由**操作数**和**操作符**组成，操作数可以是常量、变量，也可以是方法，而运算符就是数学中的运算符号，如“+”、“-”、“*”、“/”等，在表达式（z+100）中，z和100都是操作数，“+”就是运算符。Java提供了很多运算符，这些运算符除了做一般的数学运算之外，还可以做逻辑运算、位运算等。根据所使用类的不同，运算符可以分为**赋值运算符**、**算术运算符**、**逻辑运算符**、**条件运算符**以及**括号运算符**。

<!-- more -->

### 赋值运算符号

想为各种不同数据类型的变量赋值时，就需要使用赋值运算符（=），等号（=）在Java中不是“等于”的意思，二十“赋值”的意思，例如：

```java
public class OperatorDemo01 {
    public static void main(String[] args) {
        int num = 22;
        System.out.println("第一次输出：num = " + num);
        num = num - 3;
        System.out.println("第二次输出：num = " + num);
    }
}
```

第五行中，把num-3的值赋给了num，所以程序运行的结果如下：

```
第一次输出：num = 22
第二次输出：num = 19
```

当然，也可以将等号后面的值赋给其他变量，例如：

```java
int sum = num1 + num2;   // num1与num2相加之后的值再赋给变量sum存放
```

### 一元运算符

对于大部分表达式而言，运算符的前后都有操作数，但是一元运算符比较特别，它只需要一个操作数。下表列出了一元运算符的成员：

| 序号 | 一元运算符 |  描述   |
| :--: | :--------: | :-----: |
|  1   |     +      |  正号   |
|  2   |     -      |  负号   |
|  3   |     !      | NOT，否 |

下面程序演示了3种一元运算符的使用：

```java
public class OperatorDemo02 {
    public static void main(String[] args) {
        boolean b = false;                                 // 定义boolean型数据
        int x = 10;                                        // 定义一个正数
        int y = -30;                                       // 定义一个负数
        System.out.println("b = " + b + ", !b = " + !b);   // 取反
        System.out.println("x = " + x + ", -x = " + -x);   // 使用负号
        System.out.println("y = " + y + ", +y = " + +y);   // 使用正号
    }
}
```

程序运行结果如下：

```
b = false, !b = true
x = 10, -x = -10
y = -30, +y = -30
```

### 算术运算符

常用的算术运算符如下表：

| 序号 | 算术运算符 |      描述      |
| :--: | :--------: | :------------: |
|  1   |     +      |      加法      |
|  2   |     -      |      减法      |
|  3   |     *      |      乘法      |
|  4   |     /      |      除法      |
|  5   |     %      | 取模（取余数） |

程序中的运用如下：

```java
public class OperatorDemo03 {
    public static void main(String[] args) {
        int i = 10;
        int j = 3;
        System.out.println(i + "+" + j + "=" + (i + j));   // 加法操作
        System.out.println(i + "-" + j + "=" + (i - j));   // 减法操作
        System.out.println(i + "*" + j + "=" + (i * j));   // 乘法操作
        System.out.println(i + "/" + j + "=" + (i / j));   // 除法操作
        System.out.println(i + "%" + j + "=" + (i % j));   // 取模操作
    }
}
```

运行的结果如下：

```
10+3=13
10-3=7
10*3=30
10/3=3
10%3=1
```

### 关系运算符

Java中经常会在if语句中使用关系运算符，具体格式如下：

```
if (布尔表达式){
    语句;
}
```

如果括号中的布尔表达式成立，就会执行{}中的语句；若是布尔表达式不成立了，则语句不会执行。常用的关系运算符如下表所示：

| 序号 | 关系运算符 |   描述   |
| :--: | :--------: | :------: |
|  1   |     >      |   大于   |
|  2   |     <      |   小于   |
|  3   |     >=     | 大于等于 |
|  4   |     <=     | 小于等于 |
|  5   |     ==     |   等于   |
|  6   |     !=     |  不等于  |

需要注意的是，赋值运算符为等号（=），为了避免混淆，当使用关系运算符“等于”时，必须使用两个等号（==）表示。关系运算符在if语句中的使用如下：

```java
public class OperatorDemo04 {
    public static void main(String[] args) {
        if (5 > 2){                                       // 判断5是否大于2
            System.out.println("条件成立：5大于2");
        }
        if (true){                                        // 判断是否为真
            System.out.println("直接写的true");
        }
        if ((3 + 6) == (3 - 6)) {                         // 判断计算结果内容是否相等
            System.out.println("这是不可能成立的！");
        }
    }
}
```

程序运行结果如下：

```
条件成立：5大于2
直接写的true
```

可以看到程序中最后一个if语句内的内容没有执行，因为if语句中的条件满足了，才会执行if中的内容，否则不执行。另外如果if语句之中只有一条语句，那么可以不用写“{}”，但是不建议这么写。

### 自增与自减运算符

| 序号 | 自增与自减运算符 |      描述       |
| :--: | :--------------: | :-------------: |
|  1   |        ++        | 自增，变量值加1 |
|  2   |        --        | 自减，变量值减1 |

用自增与自减运算符可以使程序更加简洁欸，例如，声明一个int类型的变量a，在程序运行中想让它加1，语句如下：

```java
a = a+1;   // a加1后再赋值给a
```

将a的值加1后再赋给a存放，也可以利用自增运算符“++”写出语义相同但是语句更简洁的语句：

```java
a++;   // a加1后再赋值给a存放，语句更简洁
```

在程序中还可以看到另一种自增运算符“++”的用法，就是将自增运算符“++”写在变量的前面，如++a，这就和a++所表示的意义完全不一样。a++会先执行整个语句后再将a的值加1，而++b则先把b的值加1后，再执行整个语句。

```java
public class OperatorDemo05 {
    public static void main(String[] args) {
        int a = 3, b = 3;
        int x = 6, y = 6;
        System.out.println("a = " + a);                            // 输出变量a的值
        System.out.println("\t a++ = " + (a++) + ", a = " + a);    // 先执行后自增
        System.out.println("b = " + b);                            // 输出变量b的值
        System.out.println("\t ++b = " + (++b) + ", b = " + b);    // 先自增后执行
        System.out.println("x = " + x);                            // 输出变量x的值
        System.out.println("\t x-- = " + (x--) + ", x = " + x);    // 先执行后自减
        System.out.println("y = " + y);                            // 输出变量y的值
        System.out.println("\t --y = " + (--y) + ", y = " + y);    // 先自减后执行
    }
}
```

程序运行结果如下：

```
a = 3
	 a++ = 3, a = 4
b = 3
	 ++b = 4, b = 4
x = 6
	 x-- = 6, x = 5
y = 6
	 --y = 5, y = 5
```

### 逻辑运算符

使用逻辑运算符可以连接多个逻辑运算，常用的逻辑运算符如下表：

| 序号 | 逻辑运算符 | 描述    |
| ---- | ---------- | ------- |
| 1    | &          | AND，与 |
| 2    | &&         | 短路与  |
| 3    | &#124;         | OR，或  |
| 4    | &#124;&#124;       | 短路或  |

当使用逻辑运算符“&&”时，运算符前后的两个操作数的返回值皆为真，运算的结果才会为真；使用逻辑运算“||”时，运算符前后的两个操作数的返回值只要有一个为真，运算结果就为真。并存在以下规律：

```java
public class OperatorDemo06 {
    public static void main(String[] args) {
        boolean a = true;
        boolean b = false;
        System.out.println("a || b = " + (a || b));
        System.out.println("a | b = " + (a | b));
        System.out.println("a && b = " + (a && b));
        System.out.println("a & b = " + (a & b));
    }
}
```

程序运行结果为：

```
a || b = true
a | b = true
a && b = false
a & b = false
```

根据对逻辑操作理解，可以总结以下规律：

- 对于与操作来说，如果第一个条件为假，后面的条件不管是真是假，最终的结果都是假。
- 对于或操作来说，如果第一个条件为真，后面的条件不管是真是假，最终的结果都是真。

也就是说，对于与和或来说，最先满足的条件就是一个关键性的条件，所以在Java中设置了短路与和短路或，对于短路与和与、短路或和或有以下区别：

- 对于与来说，要求所有的条件都判断，而如果使用短路与，第一个条件又为false，则后面的条件不需要再判断。
- 对于或来说，要求所有的条件都判断，而如果使用短路或，第一个条件又为true，则后面的条件不需要再判断。

下面通过三段代码来理解以上两点：

- 测试代码（一）：观察被除数为0的情况

```java
public class OperatorDemo07 {
    public static void main(String[] args) {
        int x = 10 / 0;                    
        System.out.println("x = " + x);   // 错误，被除数为0
    }
}
```

该段程序运行之后会出现以下错误，即错误的根本原因在于除数为0：

**Exception in thread "main" java.lang.ArithmeticException: / by zero** 

- 测试代码（二）：验证“&”的作用

```java
public class OperatorDemo08 {
    public static void main(String[] args) {
        if (10 != 10 & 10 /0 == 0) {             // 非短路与
            System.out.println("条件满足");
        }
    }
}
```

程序运行后，又出现了下面的错误提示：

**Exception in thread "main" java.lang.ArithmeticException: / by zero**

造成以上错误的根本原因在于“与”操作要把所有的条件进行判断，所以在计算10/0时就出现了错误。

- 测试代码（三）：验证“&&”的作用

```java
public class OperatorDemo09 {
    public static void main(String[] args) {
        if (10 != 10 && 10/0 == 0) {               // 短路与
            System.out.println("条件满足");
        }
    }
}
```

该程序运行后，没有出现上面的错误，因为短路与判断第一个条件就为false，那么之后的条件就不用判断了，这就是短路与的作用。短路或和或也是同样的原理。

### 括号运算符

括号“()”也是Java的运算符，用于提高括号中表达式的优先级。

### 位运算符

Java中支持位运算操作，位运算操作是指进行二进制位的运算，在Java中支持的位运算符如下表所示：

| 序号  | 位运算符  |           描述           |
| :--: | :------: | :---------------------: |
|  1   |    &     |          按位与          |
|  2   |  &#124;  |          按位或          |
|  3   |    ^     | 异或（相同为0，不同为1） |
|  4   |    ~     |           取反           |
|  5   |    <<    |          左移位          |
|  6   |    >>    |          右移位          |
|  7   |   >>>    |       无符号右移位       |

在Java中所有的数据都是以二进制的形式进行运算的，每一位二进制进行与、或、异或操作的结果如下表所示：

| 序号  | 二进制数1  | 二进制数2  |  与操作（&）  |  或操作（&#124;）  | 异或操作（^） |
| :--: | :-------: | :-------: | :---------: | :----------: | :------: |
|  1   |     0     |     0     |      0      |      0       |    0     |
|  2   |     0     |     1     |      0      |      1       |    1     |
|  3   |     1     |     0     |      0      |      1       |    1     |
|  4   |     1     |     1     |      1      |      1       |    0     |

下面通过一段代码来观察位运算符：

~~~java
public class OperatorDemo10 {
    public static void main(String[] args) {
        int x = 3;                  // 3的二进制数据：00000000 00000000 00000000 00000011
        int y = 6;                  // 6的二进制数据：00000000 00000000 00000000 00000110
        System.out.println(x & y);  // 与操作的结果： 00000000 00000000 00000000 00000010
        System.out.println(x | y);  // 或操作的结果： 00000000 00000000 00000000 00000111
        System.out.println(x ^ y);  // 异或操作结果： 00000000 00000000 00000000 00000101
    }
}
~~~

运行结果如下：
~~~
2
7
5
~~~

在计算机的数据表示中只定义了整数的表现形式，并没有定义负数的表现形式，所以，负数一般用**补码**的形式表示，整数的原码、反码、补码都相同，负数的反码除符号位为1外，其余位取相反；补码就是“**反码+1**”。

求出负数的反码：

~~~java
public class OperatorDemo16 {
    public static void main(String[] args) {
        int x = -3;             // -3的二进制数据：11111111 11111111 11111111 11111101
        System.out.println(x + "的反码时：" + ~x);
    }
}
~~~

程序输出的结果位2（二进制数据：00000000 00000000 00000000 00000010），因为计算机中负数都是使用补码的形式计算，补码的计算是“反码+1”，然后对-3进行反码，操作过程如下所示：

~~~
10000000 00000000 00000000 00000011   // -3原码
11111111 11111111 11111111 11111100   // -3反码
11111111 11111111 11111111 11111101   // -3补码 = -3反码 + 1
00000000 00000000 00000000 00000010   // ~-3
~~~

在Java中也提供了左移“<<”和右移“>>”两种操作。左移操作是将运算数的二进制嘛整体左移指定位数，左移之后的空位由0来填充，例如：

~~~java
public class OperatorDemo17 {
    public static void main(String[] args) {
        int x = 3;     // 3的二进制数据： 00000000 00000000 00000000 00000011
        System.out.println(x + "左移2位之后的内容：" + (x << 2)); 
    }
}
~~~

程序输出为：

~~~
3左移2位之后的内容：12   // 12二进制数：00000000 00000000 00000000 00001100
~~~

右移操作“>>”是将运算数的二进制码整体右移，右移之后的空位以符号位填充，即如果整数就用0填充，如果是负数则用1填充，例如：

~~~java
public class OperatorDemo18 {
    public static void main(String[] args) {
        int x = 3;    // 3的二进制数据：00000000 00000000 00000000 00000011
        int y = -3;   // -3的二进制数： 11111111 11111111 11111111 11111101
        System.out.println(x + "右移2位之后的内容：" + (x >> 2));
        System.out.println(y + "右移2位之后的内容：" + (y >> 2));
    }
}
~~~

程序运行结果：

~~~
3右移2位之后的内容：0     // 3右移两位之后的二进制：00000000 00000000 00000000 00000000
-3右移2位之后的内容：-1   // -3右移两位后的二进制： 11111111 11111111 11111111 11111111
~~~

因为-3右移后的二进制依然是负数，负数用的补码表示，而补码=反码+1，所以求出对应的反码=补码-1，原码也可以根据反码求出：

* -3右移两位后的二进制补码：11111111 11111111 11111111 11111111
* 反码 = 补码-1，即补码为：   11111111 11111111 11111111 11111110
* -3右移两位后的二进制原码：10000000 00000000 00000000 00000001

以上右移操作是带符号位的右移操作，Java也提供无符号位的右移操作“>>>”，即右移后的空位由0来填充，例如：

~~~java
public class OperatorDemo19 {
    public static void main(String[] args) {
        int x = 3;    // 3的二进制数据：00000000 00000000 00000000 00000011
        int y = -3;   // -3的二进制数： 11111111 11111111 11111111 11111101
        System.out.println(x + "右移2位后的内容：" + (x >>> 2));
        System.out.println(y + "右移2位后的内容：" + (y >>> 2));
    }
}
~~~

程序运行结果：

~~~
3右移2位后的内容：0               // 3右移两位之后的二进制：00000000 00000000 00000000 00000000
-3右移2位后的内容：1073741823     // 不带符号位-3右移两位： 00111111 11111111 11111111 11111111
~~~

### 运算符的优先级

| 优先级 | 运算符                  | 类   | 结合性 |
| :----: | :---------------------: | :--: | :----: |
| 1      | ()                      | 括号运算符 | 由左至右 |
| 1      | []                      | 方括号运算符 | 由左至右 |
| 2      | !、+（正号）、-（负号） | 一元运算符 | 由右至左 |
| 2      | ~                       | 位逻辑运算符 | 由右至左 |
| 2      | ++、--                  | 自增与自减运算符 | 由右至左 |
| 3      | *、/、%                 | 算术运算符 | 由左至右 |
| 4      | +、-                    | 算术运算符 | 由左至右 |
| 5      | <<、>>                  | 位左移、位右移运算符 | 由左至右 |
| 6      | >、>=、<、<=            | 关系运算符 | 由左至右 |
| 7      | ==、!=                  | 关系运算符 | 由左至右 |
| 8      | &（位运算符AND）        | 位逻辑运算符 | 由左至右 |
| 9      | ^（位运算符XOR）        | 位逻辑运算符 | 由左至右 |
| 10     |  &#124;（位运算符OR）   | 位逻辑运算符 | 由左至右 |
| 11     | && | 逻辑运算符 | 由左至右 |
| 12     |        &#124;&#124;                 | 逻辑运算符 | 由左至右 |
| 13     | ?: | 三目运算符 | 由右至左 |

当使用同一级运算符的时候，结合性非常重要，因为它决定了谁会被先处理，即在相同优先级的运算符中，根据结合性来处理操作数。对于以上优先级没有必要完全记下，可以多使用括号改变优先级。

